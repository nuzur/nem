// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: service_nem.proto

package gen

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	Nem_ListTeams_FullMethodName                = "/nem.Nem/ListTeams"
	Nem_CreateTeam_FullMethodName               = "/nem.Nem/CreateTeam"
	Nem_UpdateTeam_FullMethodName               = "/nem.Nem/UpdateTeam"
	Nem_ListOrganizations_FullMethodName        = "/nem.Nem/ListOrganizations"
	Nem_CreateOrganization_FullMethodName       = "/nem.Nem/CreateOrganization"
	Nem_UpdateOrganization_FullMethodName       = "/nem.Nem/UpdateOrganization"
	Nem_ListProjects_FullMethodName             = "/nem.Nem/ListProjects"
	Nem_CreateProject_FullMethodName            = "/nem.Nem/CreateProject"
	Nem_UpdateProject_FullMethodName            = "/nem.Nem/UpdateProject"
	Nem_ListExtensions_FullMethodName           = "/nem.Nem/ListExtensions"
	Nem_CreateExtension_FullMethodName          = "/nem.Nem/CreateExtension"
	Nem_UpdateExtension_FullMethodName          = "/nem.Nem/UpdateExtension"
	Nem_ListExtensionVersions_FullMethodName    = "/nem.Nem/ListExtensionVersions"
	Nem_CreateExtensionVersion_FullMethodName   = "/nem.Nem/CreateExtensionVersion"
	Nem_UpdateExtensionVersion_FullMethodName   = "/nem.Nem/UpdateExtensionVersion"
	Nem_ListUsers_FullMethodName                = "/nem.Nem/ListUsers"
	Nem_CreateUser_FullMethodName               = "/nem.Nem/CreateUser"
	Nem_UpdateUser_FullMethodName               = "/nem.Nem/UpdateUser"
	Nem_ListChangeRequests_FullMethodName       = "/nem.Nem/ListChangeRequests"
	Nem_CreateChangeRequest_FullMethodName      = "/nem.Nem/CreateChangeRequest"
	Nem_UpdateChangeRequest_FullMethodName      = "/nem.Nem/UpdateChangeRequest"
	Nem_ListProjectVersions_FullMethodName      = "/nem.Nem/ListProjectVersions"
	Nem_CreateProjectVersion_FullMethodName     = "/nem.Nem/CreateProjectVersion"
	Nem_UpdateProjectVersion_FullMethodName     = "/nem.Nem/UpdateProjectVersion"
	Nem_ListUserTeams_FullMethodName            = "/nem.Nem/ListUserTeams"
	Nem_CreateUserTeam_FullMethodName           = "/nem.Nem/CreateUserTeam"
	Nem_UpdateUserTeam_FullMethodName           = "/nem.Nem/UpdateUserTeam"
	Nem_ListExtensionExecutions_FullMethodName  = "/nem.Nem/ListExtensionExecutions"
	Nem_CreateExtensionExecution_FullMethodName = "/nem.Nem/CreateExtensionExecution"
	Nem_UpdateExtensionExecution_FullMethodName = "/nem.Nem/UpdateExtensionExecution"
	Nem_ListUserConnections_FullMethodName      = "/nem.Nem/ListUserConnections"
	Nem_CreateUserConnection_FullMethodName     = "/nem.Nem/CreateUserConnection"
	Nem_UpdateUserConnection_FullMethodName     = "/nem.Nem/UpdateUserConnection"
	Nem_ListUserProjectVersions_FullMethodName  = "/nem.Nem/ListUserProjectVersions"
	Nem_CreateUserProjectVersion_FullMethodName = "/nem.Nem/CreateUserProjectVersion"
	Nem_UpdateUserProjectVersion_FullMethodName = "/nem.Nem/UpdateUserProjectVersion"
)

// NemClient is the client API for Nem service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NemClient interface {
	// team start
	ListTeams(ctx context.Context, in *ListTeamsRequest, opts ...grpc.CallOption) (*ListTeamsResponse, error)
	CreateTeam(ctx context.Context, in *CreateTeamRequest, opts ...grpc.CallOption) (*Team, error)
	UpdateTeam(ctx context.Context, in *UpdateTeamRequest, opts ...grpc.CallOption) (*Team, error)
	// organization start
	ListOrganizations(ctx context.Context, in *ListOrganizationsRequest, opts ...grpc.CallOption) (*ListOrganizationsResponse, error)
	CreateOrganization(ctx context.Context, in *CreateOrganizationRequest, opts ...grpc.CallOption) (*Organization, error)
	UpdateOrganization(ctx context.Context, in *UpdateOrganizationRequest, opts ...grpc.CallOption) (*Organization, error)
	// project start
	ListProjects(ctx context.Context, in *ListProjectsRequest, opts ...grpc.CallOption) (*ListProjectsResponse, error)
	CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*Project, error)
	UpdateProject(ctx context.Context, in *UpdateProjectRequest, opts ...grpc.CallOption) (*Project, error)
	// extension start
	ListExtensions(ctx context.Context, in *ListExtensionsRequest, opts ...grpc.CallOption) (*ListExtensionsResponse, error)
	CreateExtension(ctx context.Context, in *CreateExtensionRequest, opts ...grpc.CallOption) (*Extension, error)
	UpdateExtension(ctx context.Context, in *UpdateExtensionRequest, opts ...grpc.CallOption) (*Extension, error)
	// extension_version start
	ListExtensionVersions(ctx context.Context, in *ListExtensionVersionsRequest, opts ...grpc.CallOption) (*ListExtensionVersionsResponse, error)
	CreateExtensionVersion(ctx context.Context, in *CreateExtensionVersionRequest, opts ...grpc.CallOption) (*ExtensionVersion, error)
	UpdateExtensionVersion(ctx context.Context, in *UpdateExtensionVersionRequest, opts ...grpc.CallOption) (*ExtensionVersion, error)
	// user start
	ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error)
	CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error)
	UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error)
	// change_request start
	ListChangeRequests(ctx context.Context, in *ListChangeRequestsRequest, opts ...grpc.CallOption) (*ListChangeRequestsResponse, error)
	CreateChangeRequest(ctx context.Context, in *CreateChangeRequestRequest, opts ...grpc.CallOption) (*ChangeRequest, error)
	UpdateChangeRequest(ctx context.Context, in *UpdateChangeRequestRequest, opts ...grpc.CallOption) (*ChangeRequest, error)
	// project_version start
	ListProjectVersions(ctx context.Context, in *ListProjectVersionsRequest, opts ...grpc.CallOption) (*ListProjectVersionsResponse, error)
	CreateProjectVersion(ctx context.Context, in *CreateProjectVersionRequest, opts ...grpc.CallOption) (*ProjectVersion, error)
	UpdateProjectVersion(ctx context.Context, in *UpdateProjectVersionRequest, opts ...grpc.CallOption) (*ProjectVersion, error)
	// user_team start
	ListUserTeams(ctx context.Context, in *ListUserTeamsRequest, opts ...grpc.CallOption) (*ListUserTeamsResponse, error)
	CreateUserTeam(ctx context.Context, in *CreateUserTeamRequest, opts ...grpc.CallOption) (*UserTeam, error)
	UpdateUserTeam(ctx context.Context, in *UpdateUserTeamRequest, opts ...grpc.CallOption) (*UserTeam, error)
	// extension_execution start
	ListExtensionExecutions(ctx context.Context, in *ListExtensionExecutionsRequest, opts ...grpc.CallOption) (*ListExtensionExecutionsResponse, error)
	CreateExtensionExecution(ctx context.Context, in *CreateExtensionExecutionRequest, opts ...grpc.CallOption) (*ExtensionExecution, error)
	UpdateExtensionExecution(ctx context.Context, in *UpdateExtensionExecutionRequest, opts ...grpc.CallOption) (*ExtensionExecution, error)
	// user_connection start
	ListUserConnections(ctx context.Context, in *ListUserConnectionsRequest, opts ...grpc.CallOption) (*ListUserConnectionsResponse, error)
	CreateUserConnection(ctx context.Context, in *CreateUserConnectionRequest, opts ...grpc.CallOption) (*UserConnection, error)
	UpdateUserConnection(ctx context.Context, in *UpdateUserConnectionRequest, opts ...grpc.CallOption) (*UserConnection, error)
	// user_project_version start
	ListUserProjectVersions(ctx context.Context, in *ListUserProjectVersionsRequest, opts ...grpc.CallOption) (*ListUserProjectVersionsResponse, error)
	CreateUserProjectVersion(ctx context.Context, in *CreateUserProjectVersionRequest, opts ...grpc.CallOption) (*UserProjectVersion, error)
	UpdateUserProjectVersion(ctx context.Context, in *UpdateUserProjectVersionRequest, opts ...grpc.CallOption) (*UserProjectVersion, error)
}

type nemClient struct {
	cc grpc.ClientConnInterface
}

func NewNemClient(cc grpc.ClientConnInterface) NemClient {
	return &nemClient{cc}
}

func (c *nemClient) ListTeams(ctx context.Context, in *ListTeamsRequest, opts ...grpc.CallOption) (*ListTeamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTeamsResponse)
	err := c.cc.Invoke(ctx, Nem_ListTeams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) CreateTeam(ctx context.Context, in *CreateTeamRequest, opts ...grpc.CallOption) (*Team, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Team)
	err := c.cc.Invoke(ctx, Nem_CreateTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) UpdateTeam(ctx context.Context, in *UpdateTeamRequest, opts ...grpc.CallOption) (*Team, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Team)
	err := c.cc.Invoke(ctx, Nem_UpdateTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) ListOrganizations(ctx context.Context, in *ListOrganizationsRequest, opts ...grpc.CallOption) (*ListOrganizationsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListOrganizationsResponse)
	err := c.cc.Invoke(ctx, Nem_ListOrganizations_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) CreateOrganization(ctx context.Context, in *CreateOrganizationRequest, opts ...grpc.CallOption) (*Organization, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Organization)
	err := c.cc.Invoke(ctx, Nem_CreateOrganization_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) UpdateOrganization(ctx context.Context, in *UpdateOrganizationRequest, opts ...grpc.CallOption) (*Organization, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Organization)
	err := c.cc.Invoke(ctx, Nem_UpdateOrganization_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) ListProjects(ctx context.Context, in *ListProjectsRequest, opts ...grpc.CallOption) (*ListProjectsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProjectsResponse)
	err := c.cc.Invoke(ctx, Nem_ListProjects_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) CreateProject(ctx context.Context, in *CreateProjectRequest, opts ...grpc.CallOption) (*Project, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Project)
	err := c.cc.Invoke(ctx, Nem_CreateProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) UpdateProject(ctx context.Context, in *UpdateProjectRequest, opts ...grpc.CallOption) (*Project, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Project)
	err := c.cc.Invoke(ctx, Nem_UpdateProject_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) ListExtensions(ctx context.Context, in *ListExtensionsRequest, opts ...grpc.CallOption) (*ListExtensionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListExtensionsResponse)
	err := c.cc.Invoke(ctx, Nem_ListExtensions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) CreateExtension(ctx context.Context, in *CreateExtensionRequest, opts ...grpc.CallOption) (*Extension, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Extension)
	err := c.cc.Invoke(ctx, Nem_CreateExtension_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) UpdateExtension(ctx context.Context, in *UpdateExtensionRequest, opts ...grpc.CallOption) (*Extension, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Extension)
	err := c.cc.Invoke(ctx, Nem_UpdateExtension_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) ListExtensionVersions(ctx context.Context, in *ListExtensionVersionsRequest, opts ...grpc.CallOption) (*ListExtensionVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListExtensionVersionsResponse)
	err := c.cc.Invoke(ctx, Nem_ListExtensionVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) CreateExtensionVersion(ctx context.Context, in *CreateExtensionVersionRequest, opts ...grpc.CallOption) (*ExtensionVersion, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExtensionVersion)
	err := c.cc.Invoke(ctx, Nem_CreateExtensionVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) UpdateExtensionVersion(ctx context.Context, in *UpdateExtensionVersionRequest, opts ...grpc.CallOption) (*ExtensionVersion, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExtensionVersion)
	err := c.cc.Invoke(ctx, Nem_UpdateExtensionVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) ListUsers(ctx context.Context, in *ListUsersRequest, opts ...grpc.CallOption) (*ListUsersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUsersResponse)
	err := c.cc.Invoke(ctx, Nem_ListUsers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) CreateUser(ctx context.Context, in *CreateUserRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, Nem_CreateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) UpdateUser(ctx context.Context, in *UpdateUserRequest, opts ...grpc.CallOption) (*User, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(User)
	err := c.cc.Invoke(ctx, Nem_UpdateUser_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) ListChangeRequests(ctx context.Context, in *ListChangeRequestsRequest, opts ...grpc.CallOption) (*ListChangeRequestsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListChangeRequestsResponse)
	err := c.cc.Invoke(ctx, Nem_ListChangeRequests_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) CreateChangeRequest(ctx context.Context, in *CreateChangeRequestRequest, opts ...grpc.CallOption) (*ChangeRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeRequest)
	err := c.cc.Invoke(ctx, Nem_CreateChangeRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) UpdateChangeRequest(ctx context.Context, in *UpdateChangeRequestRequest, opts ...grpc.CallOption) (*ChangeRequest, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ChangeRequest)
	err := c.cc.Invoke(ctx, Nem_UpdateChangeRequest_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) ListProjectVersions(ctx context.Context, in *ListProjectVersionsRequest, opts ...grpc.CallOption) (*ListProjectVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListProjectVersionsResponse)
	err := c.cc.Invoke(ctx, Nem_ListProjectVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) CreateProjectVersion(ctx context.Context, in *CreateProjectVersionRequest, opts ...grpc.CallOption) (*ProjectVersion, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectVersion)
	err := c.cc.Invoke(ctx, Nem_CreateProjectVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) UpdateProjectVersion(ctx context.Context, in *UpdateProjectVersionRequest, opts ...grpc.CallOption) (*ProjectVersion, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProjectVersion)
	err := c.cc.Invoke(ctx, Nem_UpdateProjectVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) ListUserTeams(ctx context.Context, in *ListUserTeamsRequest, opts ...grpc.CallOption) (*ListUserTeamsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserTeamsResponse)
	err := c.cc.Invoke(ctx, Nem_ListUserTeams_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) CreateUserTeam(ctx context.Context, in *CreateUserTeamRequest, opts ...grpc.CallOption) (*UserTeam, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserTeam)
	err := c.cc.Invoke(ctx, Nem_CreateUserTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) UpdateUserTeam(ctx context.Context, in *UpdateUserTeamRequest, opts ...grpc.CallOption) (*UserTeam, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserTeam)
	err := c.cc.Invoke(ctx, Nem_UpdateUserTeam_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) ListExtensionExecutions(ctx context.Context, in *ListExtensionExecutionsRequest, opts ...grpc.CallOption) (*ListExtensionExecutionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListExtensionExecutionsResponse)
	err := c.cc.Invoke(ctx, Nem_ListExtensionExecutions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) CreateExtensionExecution(ctx context.Context, in *CreateExtensionExecutionRequest, opts ...grpc.CallOption) (*ExtensionExecution, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExtensionExecution)
	err := c.cc.Invoke(ctx, Nem_CreateExtensionExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) UpdateExtensionExecution(ctx context.Context, in *UpdateExtensionExecutionRequest, opts ...grpc.CallOption) (*ExtensionExecution, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExtensionExecution)
	err := c.cc.Invoke(ctx, Nem_UpdateExtensionExecution_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) ListUserConnections(ctx context.Context, in *ListUserConnectionsRequest, opts ...grpc.CallOption) (*ListUserConnectionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserConnectionsResponse)
	err := c.cc.Invoke(ctx, Nem_ListUserConnections_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) CreateUserConnection(ctx context.Context, in *CreateUserConnectionRequest, opts ...grpc.CallOption) (*UserConnection, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserConnection)
	err := c.cc.Invoke(ctx, Nem_CreateUserConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) UpdateUserConnection(ctx context.Context, in *UpdateUserConnectionRequest, opts ...grpc.CallOption) (*UserConnection, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserConnection)
	err := c.cc.Invoke(ctx, Nem_UpdateUserConnection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) ListUserProjectVersions(ctx context.Context, in *ListUserProjectVersionsRequest, opts ...grpc.CallOption) (*ListUserProjectVersionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListUserProjectVersionsResponse)
	err := c.cc.Invoke(ctx, Nem_ListUserProjectVersions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) CreateUserProjectVersion(ctx context.Context, in *CreateUserProjectVersionRequest, opts ...grpc.CallOption) (*UserProjectVersion, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserProjectVersion)
	err := c.cc.Invoke(ctx, Nem_CreateUserProjectVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nemClient) UpdateUserProjectVersion(ctx context.Context, in *UpdateUserProjectVersionRequest, opts ...grpc.CallOption) (*UserProjectVersion, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserProjectVersion)
	err := c.cc.Invoke(ctx, Nem_UpdateUserProjectVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NemServer is the server API for Nem service.
// All implementations must embed UnimplementedNemServer
// for forward compatibility.
type NemServer interface {
	// team start
	ListTeams(context.Context, *ListTeamsRequest) (*ListTeamsResponse, error)
	CreateTeam(context.Context, *CreateTeamRequest) (*Team, error)
	UpdateTeam(context.Context, *UpdateTeamRequest) (*Team, error)
	// organization start
	ListOrganizations(context.Context, *ListOrganizationsRequest) (*ListOrganizationsResponse, error)
	CreateOrganization(context.Context, *CreateOrganizationRequest) (*Organization, error)
	UpdateOrganization(context.Context, *UpdateOrganizationRequest) (*Organization, error)
	// project start
	ListProjects(context.Context, *ListProjectsRequest) (*ListProjectsResponse, error)
	CreateProject(context.Context, *CreateProjectRequest) (*Project, error)
	UpdateProject(context.Context, *UpdateProjectRequest) (*Project, error)
	// extension start
	ListExtensions(context.Context, *ListExtensionsRequest) (*ListExtensionsResponse, error)
	CreateExtension(context.Context, *CreateExtensionRequest) (*Extension, error)
	UpdateExtension(context.Context, *UpdateExtensionRequest) (*Extension, error)
	// extension_version start
	ListExtensionVersions(context.Context, *ListExtensionVersionsRequest) (*ListExtensionVersionsResponse, error)
	CreateExtensionVersion(context.Context, *CreateExtensionVersionRequest) (*ExtensionVersion, error)
	UpdateExtensionVersion(context.Context, *UpdateExtensionVersionRequest) (*ExtensionVersion, error)
	// user start
	ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error)
	CreateUser(context.Context, *CreateUserRequest) (*User, error)
	UpdateUser(context.Context, *UpdateUserRequest) (*User, error)
	// change_request start
	ListChangeRequests(context.Context, *ListChangeRequestsRequest) (*ListChangeRequestsResponse, error)
	CreateChangeRequest(context.Context, *CreateChangeRequestRequest) (*ChangeRequest, error)
	UpdateChangeRequest(context.Context, *UpdateChangeRequestRequest) (*ChangeRequest, error)
	// project_version start
	ListProjectVersions(context.Context, *ListProjectVersionsRequest) (*ListProjectVersionsResponse, error)
	CreateProjectVersion(context.Context, *CreateProjectVersionRequest) (*ProjectVersion, error)
	UpdateProjectVersion(context.Context, *UpdateProjectVersionRequest) (*ProjectVersion, error)
	// user_team start
	ListUserTeams(context.Context, *ListUserTeamsRequest) (*ListUserTeamsResponse, error)
	CreateUserTeam(context.Context, *CreateUserTeamRequest) (*UserTeam, error)
	UpdateUserTeam(context.Context, *UpdateUserTeamRequest) (*UserTeam, error)
	// extension_execution start
	ListExtensionExecutions(context.Context, *ListExtensionExecutionsRequest) (*ListExtensionExecutionsResponse, error)
	CreateExtensionExecution(context.Context, *CreateExtensionExecutionRequest) (*ExtensionExecution, error)
	UpdateExtensionExecution(context.Context, *UpdateExtensionExecutionRequest) (*ExtensionExecution, error)
	// user_connection start
	ListUserConnections(context.Context, *ListUserConnectionsRequest) (*ListUserConnectionsResponse, error)
	CreateUserConnection(context.Context, *CreateUserConnectionRequest) (*UserConnection, error)
	UpdateUserConnection(context.Context, *UpdateUserConnectionRequest) (*UserConnection, error)
	// user_project_version start
	ListUserProjectVersions(context.Context, *ListUserProjectVersionsRequest) (*ListUserProjectVersionsResponse, error)
	CreateUserProjectVersion(context.Context, *CreateUserProjectVersionRequest) (*UserProjectVersion, error)
	UpdateUserProjectVersion(context.Context, *UpdateUserProjectVersionRequest) (*UserProjectVersion, error)
	mustEmbedUnimplementedNemServer()
}

// UnimplementedNemServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNemServer struct{}

func (UnimplementedNemServer) ListTeams(context.Context, *ListTeamsRequest) (*ListTeamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListTeams not implemented")
}
func (UnimplementedNemServer) CreateTeam(context.Context, *CreateTeamRequest) (*Team, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTeam not implemented")
}
func (UnimplementedNemServer) UpdateTeam(context.Context, *UpdateTeamRequest) (*Team, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTeam not implemented")
}
func (UnimplementedNemServer) ListOrganizations(context.Context, *ListOrganizationsRequest) (*ListOrganizationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListOrganizations not implemented")
}
func (UnimplementedNemServer) CreateOrganization(context.Context, *CreateOrganizationRequest) (*Organization, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOrganization not implemented")
}
func (UnimplementedNemServer) UpdateOrganization(context.Context, *UpdateOrganizationRequest) (*Organization, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOrganization not implemented")
}
func (UnimplementedNemServer) ListProjects(context.Context, *ListProjectsRequest) (*ListProjectsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProjects not implemented")
}
func (UnimplementedNemServer) CreateProject(context.Context, *CreateProjectRequest) (*Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProject not implemented")
}
func (UnimplementedNemServer) UpdateProject(context.Context, *UpdateProjectRequest) (*Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProject not implemented")
}
func (UnimplementedNemServer) ListExtensions(context.Context, *ListExtensionsRequest) (*ListExtensionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExtensions not implemented")
}
func (UnimplementedNemServer) CreateExtension(context.Context, *CreateExtensionRequest) (*Extension, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateExtension not implemented")
}
func (UnimplementedNemServer) UpdateExtension(context.Context, *UpdateExtensionRequest) (*Extension, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExtension not implemented")
}
func (UnimplementedNemServer) ListExtensionVersions(context.Context, *ListExtensionVersionsRequest) (*ListExtensionVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExtensionVersions not implemented")
}
func (UnimplementedNemServer) CreateExtensionVersion(context.Context, *CreateExtensionVersionRequest) (*ExtensionVersion, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateExtensionVersion not implemented")
}
func (UnimplementedNemServer) UpdateExtensionVersion(context.Context, *UpdateExtensionVersionRequest) (*ExtensionVersion, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExtensionVersion not implemented")
}
func (UnimplementedNemServer) ListUsers(context.Context, *ListUsersRequest) (*ListUsersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsers not implemented")
}
func (UnimplementedNemServer) CreateUser(context.Context, *CreateUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUser not implemented")
}
func (UnimplementedNemServer) UpdateUser(context.Context, *UpdateUserRequest) (*User, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUser not implemented")
}
func (UnimplementedNemServer) ListChangeRequests(context.Context, *ListChangeRequestsRequest) (*ListChangeRequestsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListChangeRequests not implemented")
}
func (UnimplementedNemServer) CreateChangeRequest(context.Context, *CreateChangeRequestRequest) (*ChangeRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateChangeRequest not implemented")
}
func (UnimplementedNemServer) UpdateChangeRequest(context.Context, *UpdateChangeRequestRequest) (*ChangeRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChangeRequest not implemented")
}
func (UnimplementedNemServer) ListProjectVersions(context.Context, *ListProjectVersionsRequest) (*ListProjectVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProjectVersions not implemented")
}
func (UnimplementedNemServer) CreateProjectVersion(context.Context, *CreateProjectVersionRequest) (*ProjectVersion, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateProjectVersion not implemented")
}
func (UnimplementedNemServer) UpdateProjectVersion(context.Context, *UpdateProjectVersionRequest) (*ProjectVersion, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateProjectVersion not implemented")
}
func (UnimplementedNemServer) ListUserTeams(context.Context, *ListUserTeamsRequest) (*ListUserTeamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserTeams not implemented")
}
func (UnimplementedNemServer) CreateUserTeam(context.Context, *CreateUserTeamRequest) (*UserTeam, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUserTeam not implemented")
}
func (UnimplementedNemServer) UpdateUserTeam(context.Context, *UpdateUserTeamRequest) (*UserTeam, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserTeam not implemented")
}
func (UnimplementedNemServer) ListExtensionExecutions(context.Context, *ListExtensionExecutionsRequest) (*ListExtensionExecutionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListExtensionExecutions not implemented")
}
func (UnimplementedNemServer) CreateExtensionExecution(context.Context, *CreateExtensionExecutionRequest) (*ExtensionExecution, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateExtensionExecution not implemented")
}
func (UnimplementedNemServer) UpdateExtensionExecution(context.Context, *UpdateExtensionExecutionRequest) (*ExtensionExecution, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExtensionExecution not implemented")
}
func (UnimplementedNemServer) ListUserConnections(context.Context, *ListUserConnectionsRequest) (*ListUserConnectionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserConnections not implemented")
}
func (UnimplementedNemServer) CreateUserConnection(context.Context, *CreateUserConnectionRequest) (*UserConnection, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUserConnection not implemented")
}
func (UnimplementedNemServer) UpdateUserConnection(context.Context, *UpdateUserConnectionRequest) (*UserConnection, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserConnection not implemented")
}
func (UnimplementedNemServer) ListUserProjectVersions(context.Context, *ListUserProjectVersionsRequest) (*ListUserProjectVersionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUserProjectVersions not implemented")
}
func (UnimplementedNemServer) CreateUserProjectVersion(context.Context, *CreateUserProjectVersionRequest) (*UserProjectVersion, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateUserProjectVersion not implemented")
}
func (UnimplementedNemServer) UpdateUserProjectVersion(context.Context, *UpdateUserProjectVersionRequest) (*UserProjectVersion, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserProjectVersion not implemented")
}
func (UnimplementedNemServer) mustEmbedUnimplementedNemServer() {}
func (UnimplementedNemServer) testEmbeddedByValue()             {}

// UnsafeNemServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NemServer will
// result in compilation errors.
type UnsafeNemServer interface {
	mustEmbedUnimplementedNemServer()
}

func RegisterNemServer(s grpc.ServiceRegistrar, srv NemServer) {
	// If the following call pancis, it indicates UnimplementedNemServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&Nem_ServiceDesc, srv)
}

func _Nem_ListTeams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTeamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).ListTeams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_ListTeams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).ListTeams(ctx, req.(*ListTeamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_CreateTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).CreateTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_CreateTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).CreateTeam(ctx, req.(*CreateTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_UpdateTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).UpdateTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_UpdateTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).UpdateTeam(ctx, req.(*UpdateTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_ListOrganizations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrganizationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).ListOrganizations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_ListOrganizations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).ListOrganizations(ctx, req.(*ListOrganizationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_CreateOrganization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateOrganizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).CreateOrganization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_CreateOrganization_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).CreateOrganization(ctx, req.(*CreateOrganizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_UpdateOrganization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateOrganizationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).UpdateOrganization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_UpdateOrganization_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).UpdateOrganization(ctx, req.(*UpdateOrganizationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_ListProjects_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).ListProjects(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_ListProjects_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).ListProjects(ctx, req.(*ListProjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_CreateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).CreateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_CreateProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).CreateProject(ctx, req.(*CreateProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_UpdateProject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).UpdateProject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_UpdateProject_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).UpdateProject(ctx, req.(*UpdateProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_ListExtensions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExtensionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).ListExtensions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_ListExtensions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).ListExtensions(ctx, req.(*ListExtensionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_CreateExtension_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExtensionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).CreateExtension(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_CreateExtension_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).CreateExtension(ctx, req.(*CreateExtensionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_UpdateExtension_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExtensionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).UpdateExtension(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_UpdateExtension_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).UpdateExtension(ctx, req.(*UpdateExtensionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_ListExtensionVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExtensionVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).ListExtensionVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_ListExtensionVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).ListExtensionVersions(ctx, req.(*ListExtensionVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_CreateExtensionVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExtensionVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).CreateExtensionVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_CreateExtensionVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).CreateExtensionVersion(ctx, req.(*CreateExtensionVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_UpdateExtensionVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExtensionVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).UpdateExtensionVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_UpdateExtensionVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).UpdateExtensionVersion(ctx, req.(*UpdateExtensionVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_ListUsers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).ListUsers(ctx, req.(*ListUsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_CreateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).CreateUser(ctx, req.(*CreateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_UpdateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).UpdateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_UpdateUser_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).UpdateUser(ctx, req.(*UpdateUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_ListChangeRequests_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChangeRequestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).ListChangeRequests(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_ListChangeRequests_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).ListChangeRequests(ctx, req.(*ListChangeRequestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_CreateChangeRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateChangeRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).CreateChangeRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_CreateChangeRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).CreateChangeRequest(ctx, req.(*CreateChangeRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_UpdateChangeRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateChangeRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).UpdateChangeRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_UpdateChangeRequest_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).UpdateChangeRequest(ctx, req.(*UpdateChangeRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_ListProjectVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProjectVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).ListProjectVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_ListProjectVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).ListProjectVersions(ctx, req.(*ListProjectVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_CreateProjectVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateProjectVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).CreateProjectVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_CreateProjectVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).CreateProjectVersion(ctx, req.(*CreateProjectVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_UpdateProjectVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateProjectVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).UpdateProjectVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_UpdateProjectVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).UpdateProjectVersion(ctx, req.(*UpdateProjectVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_ListUserTeams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserTeamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).ListUserTeams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_ListUserTeams_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).ListUserTeams(ctx, req.(*ListUserTeamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_CreateUserTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).CreateUserTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_CreateUserTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).CreateUserTeam(ctx, req.(*CreateUserTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_UpdateUserTeam_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserTeamRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).UpdateUserTeam(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_UpdateUserTeam_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).UpdateUserTeam(ctx, req.(*UpdateUserTeamRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_ListExtensionExecutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExtensionExecutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).ListExtensionExecutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_ListExtensionExecutions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).ListExtensionExecutions(ctx, req.(*ListExtensionExecutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_CreateExtensionExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExtensionExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).CreateExtensionExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_CreateExtensionExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).CreateExtensionExecution(ctx, req.(*CreateExtensionExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_UpdateExtensionExecution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExtensionExecutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).UpdateExtensionExecution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_UpdateExtensionExecution_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).UpdateExtensionExecution(ctx, req.(*UpdateExtensionExecutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_ListUserConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserConnectionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).ListUserConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_ListUserConnections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).ListUserConnections(ctx, req.(*ListUserConnectionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_CreateUserConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).CreateUserConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_CreateUserConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).CreateUserConnection(ctx, req.(*CreateUserConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_UpdateUserConnection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserConnectionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).UpdateUserConnection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_UpdateUserConnection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).UpdateUserConnection(ctx, req.(*UpdateUserConnectionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_ListUserProjectVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUserProjectVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).ListUserProjectVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_ListUserProjectVersions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).ListUserProjectVersions(ctx, req.(*ListUserProjectVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_CreateUserProjectVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserProjectVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).CreateUserProjectVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_CreateUserProjectVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).CreateUserProjectVersion(ctx, req.(*CreateUserProjectVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Nem_UpdateUserProjectVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUserProjectVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NemServer).UpdateUserProjectVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Nem_UpdateUserProjectVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NemServer).UpdateUserProjectVersion(ctx, req.(*UpdateUserProjectVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Nem_ServiceDesc is the grpc.ServiceDesc for Nem service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Nem_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "nem.Nem",
	HandlerType: (*NemServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListTeams",
			Handler:    _Nem_ListTeams_Handler,
		},
		{
			MethodName: "CreateTeam",
			Handler:    _Nem_CreateTeam_Handler,
		},
		{
			MethodName: "UpdateTeam",
			Handler:    _Nem_UpdateTeam_Handler,
		},
		{
			MethodName: "ListOrganizations",
			Handler:    _Nem_ListOrganizations_Handler,
		},
		{
			MethodName: "CreateOrganization",
			Handler:    _Nem_CreateOrganization_Handler,
		},
		{
			MethodName: "UpdateOrganization",
			Handler:    _Nem_UpdateOrganization_Handler,
		},
		{
			MethodName: "ListProjects",
			Handler:    _Nem_ListProjects_Handler,
		},
		{
			MethodName: "CreateProject",
			Handler:    _Nem_CreateProject_Handler,
		},
		{
			MethodName: "UpdateProject",
			Handler:    _Nem_UpdateProject_Handler,
		},
		{
			MethodName: "ListExtensions",
			Handler:    _Nem_ListExtensions_Handler,
		},
		{
			MethodName: "CreateExtension",
			Handler:    _Nem_CreateExtension_Handler,
		},
		{
			MethodName: "UpdateExtension",
			Handler:    _Nem_UpdateExtension_Handler,
		},
		{
			MethodName: "ListExtensionVersions",
			Handler:    _Nem_ListExtensionVersions_Handler,
		},
		{
			MethodName: "CreateExtensionVersion",
			Handler:    _Nem_CreateExtensionVersion_Handler,
		},
		{
			MethodName: "UpdateExtensionVersion",
			Handler:    _Nem_UpdateExtensionVersion_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _Nem_ListUsers_Handler,
		},
		{
			MethodName: "CreateUser",
			Handler:    _Nem_CreateUser_Handler,
		},
		{
			MethodName: "UpdateUser",
			Handler:    _Nem_UpdateUser_Handler,
		},
		{
			MethodName: "ListChangeRequests",
			Handler:    _Nem_ListChangeRequests_Handler,
		},
		{
			MethodName: "CreateChangeRequest",
			Handler:    _Nem_CreateChangeRequest_Handler,
		},
		{
			MethodName: "UpdateChangeRequest",
			Handler:    _Nem_UpdateChangeRequest_Handler,
		},
		{
			MethodName: "ListProjectVersions",
			Handler:    _Nem_ListProjectVersions_Handler,
		},
		{
			MethodName: "CreateProjectVersion",
			Handler:    _Nem_CreateProjectVersion_Handler,
		},
		{
			MethodName: "UpdateProjectVersion",
			Handler:    _Nem_UpdateProjectVersion_Handler,
		},
		{
			MethodName: "ListUserTeams",
			Handler:    _Nem_ListUserTeams_Handler,
		},
		{
			MethodName: "CreateUserTeam",
			Handler:    _Nem_CreateUserTeam_Handler,
		},
		{
			MethodName: "UpdateUserTeam",
			Handler:    _Nem_UpdateUserTeam_Handler,
		},
		{
			MethodName: "ListExtensionExecutions",
			Handler:    _Nem_ListExtensionExecutions_Handler,
		},
		{
			MethodName: "CreateExtensionExecution",
			Handler:    _Nem_CreateExtensionExecution_Handler,
		},
		{
			MethodName: "UpdateExtensionExecution",
			Handler:    _Nem_UpdateExtensionExecution_Handler,
		},
		{
			MethodName: "ListUserConnections",
			Handler:    _Nem_ListUserConnections_Handler,
		},
		{
			MethodName: "CreateUserConnection",
			Handler:    _Nem_CreateUserConnection_Handler,
		},
		{
			MethodName: "UpdateUserConnection",
			Handler:    _Nem_UpdateUserConnection_Handler,
		},
		{
			MethodName: "ListUserProjectVersions",
			Handler:    _Nem_ListUserProjectVersions_Handler,
		},
		{
			MethodName: "CreateUserProjectVersion",
			Handler:    _Nem_CreateUserProjectVersion_Handler,
		},
		{
			MethodName: "UpdateUserProjectVersion",
			Handler:    _Nem_UpdateUserProjectVersion_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "service_nem.proto",
}

// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: selects.sql

package nemdb

import (
	"context"
	"database/sql"
)

const fetchChangeRequestByChangeType = `-- name: FetchChangeRequestByChangeType :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeParams struct {
	ChangeType int64 `json:"change_type"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeType(ctx context.Context, arg FetchChangeRequestByChangeTypeParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeType, arg.ChangeType, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndReviewStatus = `-- name: FetchChangeRequestByChangeTypeAndReviewStatus :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND review_status = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndReviewStatusParams struct {
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndReviewStatus(ctx context.Context, arg FetchChangeRequestByChangeTypeAndReviewStatusParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndReviewStatus,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndReviewStatusAndStatus = `-- name: FetchChangeRequestByChangeTypeAndReviewStatusAndStatus :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND review_status = ? AND status = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndReviewStatusAndStatusParams struct {
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndReviewStatusAndStatus(ctx context.Context, arg FetchChangeRequestByChangeTypeAndReviewStatusAndStatusParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndReviewStatusAndStatus,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtASC = `-- name: FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND review_status = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtASCParams struct {
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtASC,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND review_status = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtDESCParams struct {
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtDESC,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND review_status = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtASCParams struct {
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtASC,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND review_status = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtDESCParams struct {
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtDESC,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndReviewStatusOrderedByCreatedAtASC = `-- name: FetchChangeRequestByChangeTypeAndReviewStatusOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND review_status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndReviewStatusOrderedByCreatedAtASCParams struct {
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndReviewStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByChangeTypeAndReviewStatusOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndReviewStatusOrderedByCreatedAtASC,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndReviewStatusOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByChangeTypeAndReviewStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND review_status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndReviewStatusOrderedByCreatedAtDESCParams struct {
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndReviewStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByChangeTypeAndReviewStatusOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndReviewStatusOrderedByCreatedAtDESC,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndReviewStatusOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByChangeTypeAndReviewStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND review_status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndReviewStatusOrderedByUpdatedAtASCParams struct {
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndReviewStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByChangeTypeAndReviewStatusOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndReviewStatusOrderedByUpdatedAtASC,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndReviewStatusOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByChangeTypeAndReviewStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND review_status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndReviewStatusOrderedByUpdatedAtDESCParams struct {
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndReviewStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByChangeTypeAndReviewStatusOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndReviewStatusOrderedByUpdatedAtDESC,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndStatus = `-- name: FetchChangeRequestByChangeTypeAndStatus :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND status = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndStatusParams struct {
	ChangeType int64 `json:"change_type"`
	Status     int64 `json:"status"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndStatus(ctx context.Context, arg FetchChangeRequestByChangeTypeAndStatusParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndStatus,
		arg.ChangeType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndStatusOrderedByCreatedAtASC = `-- name: FetchChangeRequestByChangeTypeAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndStatusOrderedByCreatedAtASCParams struct {
	ChangeType int64 `json:"change_type"`
	Status     int64 `json:"status"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByChangeTypeAndStatusOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndStatusOrderedByCreatedAtASC,
		arg.ChangeType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndStatusOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByChangeTypeAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndStatusOrderedByCreatedAtDESCParams struct {
	ChangeType int64 `json:"change_type"`
	Status     int64 `json:"status"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByChangeTypeAndStatusOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndStatusOrderedByCreatedAtDESC,
		arg.ChangeType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndStatusOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByChangeTypeAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndStatusOrderedByUpdatedAtASCParams struct {
	ChangeType int64 `json:"change_type"`
	Status     int64 `json:"status"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByChangeTypeAndStatusOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndStatusOrderedByUpdatedAtASC,
		arg.ChangeType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeAndStatusOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByChangeTypeAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeAndStatusOrderedByUpdatedAtDESCParams struct {
	ChangeType int64 `json:"change_type"`
	Status     int64 `json:"status"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByChangeTypeAndStatusOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeAndStatusOrderedByUpdatedAtDESC,
		arg.ChangeType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeOrderedByCreatedAtASC = `-- name: FetchChangeRequestByChangeTypeOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeOrderedByCreatedAtASCParams struct {
	ChangeType int64 `json:"change_type"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByChangeTypeOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeOrderedByCreatedAtASC, arg.ChangeType, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByChangeTypeOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeOrderedByCreatedAtDESCParams struct {
	ChangeType int64 `json:"change_type"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByChangeTypeOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeOrderedByCreatedAtDESC, arg.ChangeType, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByChangeTypeOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeOrderedByUpdatedAtASCParams struct {
	ChangeType int64 `json:"change_type"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByChangeTypeOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeOrderedByUpdatedAtASC, arg.ChangeType, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByChangeTypeOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByChangeTypeOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     change_type = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByChangeTypeOrderedByUpdatedAtDESCParams struct {
	ChangeType int64 `json:"change_type"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByChangeTypeOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByChangeTypeOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByChangeTypeOrderedByUpdatedAtDESC, arg.ChangeType, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByReviewStatus = `-- name: FetchChangeRequestByReviewStatus :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     review_status = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByReviewStatusParams struct {
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByReviewStatus(ctx context.Context, arg FetchChangeRequestByReviewStatusParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByReviewStatus, arg.ReviewStatus, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByReviewStatusAndStatus = `-- name: FetchChangeRequestByReviewStatusAndStatus :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     review_status = ? AND status = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByReviewStatusAndStatusParams struct {
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByReviewStatusAndStatus(ctx context.Context, arg FetchChangeRequestByReviewStatusAndStatusParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByReviewStatusAndStatus,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByReviewStatusAndStatusOrderedByCreatedAtASC = `-- name: FetchChangeRequestByReviewStatusAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     review_status = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByReviewStatusAndStatusOrderedByCreatedAtASCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByReviewStatusAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByReviewStatusAndStatusOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByReviewStatusAndStatusOrderedByCreatedAtASC,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByReviewStatusAndStatusOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByReviewStatusAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     review_status = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByReviewStatusAndStatusOrderedByCreatedAtDESCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByReviewStatusAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByReviewStatusAndStatusOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByReviewStatusAndStatusOrderedByCreatedAtDESC,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByReviewStatusAndStatusOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByReviewStatusAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     review_status = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByReviewStatusAndStatusOrderedByUpdatedAtASCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByReviewStatusAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByReviewStatusAndStatusOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByReviewStatusAndStatusOrderedByUpdatedAtASC,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByReviewStatusAndStatusOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByReviewStatusAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     review_status = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByReviewStatusAndStatusOrderedByUpdatedAtDESCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByReviewStatusAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByReviewStatusAndStatusOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByReviewStatusAndStatusOrderedByUpdatedAtDESC,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByReviewStatusOrderedByCreatedAtASC = `-- name: FetchChangeRequestByReviewStatusOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     review_status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByReviewStatusOrderedByCreatedAtASCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByReviewStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByReviewStatusOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByReviewStatusOrderedByCreatedAtASC, arg.ReviewStatus, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByReviewStatusOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByReviewStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     review_status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByReviewStatusOrderedByCreatedAtDESCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByReviewStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByReviewStatusOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByReviewStatusOrderedByCreatedAtDESC, arg.ReviewStatus, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByReviewStatusOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByReviewStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     review_status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByReviewStatusOrderedByUpdatedAtASCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByReviewStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByReviewStatusOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByReviewStatusOrderedByUpdatedAtASC, arg.ReviewStatus, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByReviewStatusOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByReviewStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     review_status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByReviewStatusOrderedByUpdatedAtDESCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByReviewStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByReviewStatusOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByReviewStatusOrderedByUpdatedAtDESC, arg.ReviewStatus, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByStatus = `-- name: FetchChangeRequestByStatus :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByStatus(ctx context.Context, arg FetchChangeRequestByStatusParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByStatusOrderedByCreatedAtASC = `-- name: FetchChangeRequestByStatusOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByStatusOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByStatusOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByStatusOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByStatusOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByStatusOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByStatusOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByStatusOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByUUID = `-- name: FetchChangeRequestByUUID :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     uuid = ?
`

func (q *Queries) FetchChangeRequestByUUID(ctx context.Context, uuid string) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByUUIDForUpdate = `-- name: FetchChangeRequestByUUIDForUpdate :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchChangeRequestByUUIDForUpdate(ctx context.Context, uuid string) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersion = `-- name: FetchChangeRequestByVersion :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByVersionParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersion(ctx context.Context, arg FetchChangeRequestByVersionParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersion, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeType = `-- name: FetchChangeRequestByVersionAndChangeType :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeParams struct {
	Version    int64 `json:"version"`
	ChangeType int64 `json:"change_type"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeType(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeType,
		arg.Version,
		arg.ChangeType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndReviewStatus = `-- name: FetchChangeRequestByVersionAndChangeTypeAndReviewStatus :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND review_status = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndReviewStatusParams struct {
	Version      int64 `json:"version"`
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndReviewStatus(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndReviewStatusParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndReviewStatus,
		arg.Version,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatus = `-- name: FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatus :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND review_status = ? AND status = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusParams struct {
	Version      int64 `json:"version"`
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatus(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatus,
		arg.Version,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtASC = `-- name: FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND review_status = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtASCParams struct {
	Version      int64 `json:"version"`
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND review_status = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtDESCParams struct {
	Version      int64 `json:"version"`
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND review_status = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtASCParams struct {
	Version      int64 `json:"version"`
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND review_status = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtDESCParams struct {
	Version      int64 `json:"version"`
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndReviewStatusAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByCreatedAtASC = `-- name: FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND review_status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByCreatedAtASCParams struct {
	Version      int64 `json:"version"`
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND review_status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByCreatedAtDESCParams struct {
	Version      int64 `json:"version"`
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND review_status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByUpdatedAtASCParams struct {
	Version      int64 `json:"version"`
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND review_status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByUpdatedAtDESCParams struct {
	Version      int64 `json:"version"`
	ChangeType   int64 `json:"change_type"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndReviewStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.ChangeType,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndStatus = `-- name: FetchChangeRequestByVersionAndChangeTypeAndStatus :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND status = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndStatusParams struct {
	Version    int64 `json:"version"`
	ChangeType int64 `json:"change_type"`
	Status     int64 `json:"status"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndStatus(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndStatusParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndStatus,
		arg.Version,
		arg.ChangeType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByCreatedAtASC = `-- name: FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByCreatedAtASCParams struct {
	Version    int64 `json:"version"`
	ChangeType int64 `json:"change_type"`
	Status     int64 `json:"status"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.ChangeType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByCreatedAtDESCParams struct {
	Version    int64 `json:"version"`
	ChangeType int64 `json:"change_type"`
	Status     int64 `json:"status"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.ChangeType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByUpdatedAtASCParams struct {
	Version    int64 `json:"version"`
	ChangeType int64 `json:"change_type"`
	Status     int64 `json:"status"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.ChangeType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByUpdatedAtDESCParams struct {
	Version    int64 `json:"version"`
	ChangeType int64 `json:"change_type"`
	Status     int64 `json:"status"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.ChangeType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeOrderedByCreatedAtASC = `-- name: FetchChangeRequestByVersionAndChangeTypeOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeOrderedByCreatedAtASCParams struct {
	Version    int64 `json:"version"`
	ChangeType int64 `json:"change_type"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeOrderedByCreatedAtASC,
		arg.Version,
		arg.ChangeType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByVersionAndChangeTypeOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeOrderedByCreatedAtDESCParams struct {
	Version    int64 `json:"version"`
	ChangeType int64 `json:"change_type"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeOrderedByCreatedAtDESC,
		arg.Version,
		arg.ChangeType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByVersionAndChangeTypeOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeOrderedByUpdatedAtASCParams struct {
	Version    int64 `json:"version"`
	ChangeType int64 `json:"change_type"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeOrderedByUpdatedAtASC,
		arg.Version,
		arg.ChangeType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndChangeTypeOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByVersionAndChangeTypeOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND change_type = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndChangeTypeOrderedByUpdatedAtDESCParams struct {
	Version    int64 `json:"version"`
	ChangeType int64 `json:"change_type"`
	Offset     int32 `json:"offset"`
	Limit      int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndChangeTypeOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndChangeTypeOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndChangeTypeOrderedByUpdatedAtDESC,
		arg.Version,
		arg.ChangeType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndReviewStatus = `-- name: FetchChangeRequestByVersionAndReviewStatus :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND review_status = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndReviewStatusParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndReviewStatus(ctx context.Context, arg FetchChangeRequestByVersionAndReviewStatusParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndReviewStatus,
		arg.Version,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndReviewStatusAndStatus = `-- name: FetchChangeRequestByVersionAndReviewStatusAndStatus :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND review_status = ? AND status = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndReviewStatusAndStatusParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndReviewStatusAndStatus(ctx context.Context, arg FetchChangeRequestByVersionAndReviewStatusAndStatusParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndReviewStatusAndStatus,
		arg.Version,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByCreatedAtASC = `-- name: FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND review_status = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByCreatedAtASCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND review_status = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByCreatedAtDESCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND review_status = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByUpdatedAtASCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND review_status = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByUpdatedAtDESCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndReviewStatusAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndReviewStatusOrderedByCreatedAtASC = `-- name: FetchChangeRequestByVersionAndReviewStatusOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND review_status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndReviewStatusOrderedByCreatedAtASCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndReviewStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndReviewStatusOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndReviewStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndReviewStatusOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByVersionAndReviewStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND review_status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndReviewStatusOrderedByCreatedAtDESCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndReviewStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndReviewStatusOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndReviewStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndReviewStatusOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByVersionAndReviewStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND review_status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndReviewStatusOrderedByUpdatedAtASCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndReviewStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndReviewStatusOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndReviewStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndReviewStatusOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByVersionAndReviewStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND review_status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndReviewStatusOrderedByUpdatedAtDESCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndReviewStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndReviewStatusOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndReviewStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndStatus = `-- name: FetchChangeRequestByVersionAndStatus :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND status = ?  
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndStatusParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndStatus(ctx context.Context, arg FetchChangeRequestByVersionAndStatusParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndStatus,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndStatusOrderedByCreatedAtASC = `-- name: FetchChangeRequestByVersionAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndStatusOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndStatusOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndStatusOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByVersionAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndStatusOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndStatusOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndStatusOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByVersionAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndStatusOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionAndStatusOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionAndStatusOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByVersionAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionAndStatusOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionAndStatusOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionOrderedByCreatedAtASC = `-- name: FetchChangeRequestByVersionOrderedByCreatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionOrderedByCreatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionOrderedByCreatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionOrderedByCreatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionOrderedByCreatedAtDESC = `-- name: FetchChangeRequestByVersionOrderedByCreatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionOrderedByCreatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionOrderedByCreatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionOrderedByCreatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionOrderedByUpdatedAtASC = `-- name: FetchChangeRequestByVersionOrderedByUpdatedAtASC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionOrderedByUpdatedAtASC(ctx context.Context, arg FetchChangeRequestByVersionOrderedByUpdatedAtASCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionOrderedByUpdatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchChangeRequestByVersionOrderedByUpdatedAtDESC = `-- name: FetchChangeRequestByVersionOrderedByUpdatedAtDESC :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
     version = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchChangeRequestByVersionOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchChangeRequestByVersionOrderedByUpdatedAtDESC(ctx context.Context, arg FetchChangeRequestByVersionOrderedByUpdatedAtDESCParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, fetchChangeRequestByVersionOrderedByUpdatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionType = `-- name: FetchExtensionByExtensionType :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ?  
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeParams struct {
	ExtensionType int64 `json:"extension_type"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionType(ctx context.Context, arg FetchExtensionByExtensionTypeParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionType, arg.ExtensionType, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndPublic = `-- name: FetchExtensionByExtensionTypeAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndPublicParams struct {
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndPublic(ctx context.Context, arg FetchExtensionByExtensionTypeAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndPublic,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndPublicAndStatus = `-- name: FetchExtensionByExtensionTypeAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndPublicAndStatusParams struct {
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndPublicAndStatus(ctx context.Context, arg FetchExtensionByExtensionTypeAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndPublicAndStatus,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByExtensionTypeAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndPublicOrderedByCreatedAtASCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByExtensionTypeAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndPublicOrderedByCreatedAtASC,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByExtensionTypeAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndPublicOrderedByCreatedAtDESCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByExtensionTypeAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndPublicOrderedByCreatedAtDESC,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByExtensionTypeAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndPublicOrderedByUpdatedAtASCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByExtensionTypeAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndPublicOrderedByUpdatedAtASC,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByExtensionTypeAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndPublicOrderedByUpdatedAtDESCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByExtensionTypeAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndPublicOrderedByUpdatedAtDESC,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndStatus = `-- name: FetchExtensionByExtensionTypeAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndStatusParams struct {
	ExtensionType int64 `json:"extension_type"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndStatus(ctx context.Context, arg FetchExtensionByExtensionTypeAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndStatus,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByExtensionTypeAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndStatusOrderedByCreatedAtASCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByExtensionTypeAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndStatusOrderedByCreatedAtASC,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByExtensionTypeAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndStatusOrderedByCreatedAtDESCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByExtensionTypeAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndStatusOrderedByCreatedAtDESC,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByExtensionTypeAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndStatusOrderedByUpdatedAtASCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByExtensionTypeAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndStatusOrderedByUpdatedAtASC,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByExtensionTypeAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeAndStatusOrderedByUpdatedAtDESCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByExtensionTypeAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeAndStatusOrderedByUpdatedAtDESC,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeOrderedByCreatedAtASC = `-- name: FetchExtensionByExtensionTypeOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeOrderedByCreatedAtASCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByExtensionTypeOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeOrderedByCreatedAtASC, arg.ExtensionType, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeOrderedByCreatedAtDESC = `-- name: FetchExtensionByExtensionTypeOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeOrderedByCreatedAtDESCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByExtensionTypeOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeOrderedByCreatedAtDESC, arg.ExtensionType, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeOrderedByUpdatedAtASC = `-- name: FetchExtensionByExtensionTypeOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeOrderedByUpdatedAtASCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByExtensionTypeOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeOrderedByUpdatedAtASC, arg.ExtensionType, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByExtensionTypeOrderedByUpdatedAtDESC = `-- name: FetchExtensionByExtensionTypeOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     extension_type = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByExtensionTypeOrderedByUpdatedAtDESCParams struct {
	ExtensionType int64 `json:"extension_type"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByExtensionTypeOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByExtensionTypeOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByExtensionTypeOrderedByUpdatedAtDESC, arg.ExtensionType, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifier = `-- name: FetchExtensionByIdentifier :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierParams struct {
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifier(ctx context.Context, arg FetchExtensionByIdentifierParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifier, arg.Identifier, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionType = `-- name: FetchExtensionByIdentifierAndExtensionType :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionType(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionType,
		arg.Identifier,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndPublic = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndPublicParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndPublic(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndPublic,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatus = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatus(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatus,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtASC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndStatus = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndStatusParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndStatus(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndStatus,
		arg.Identifier,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtASC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndExtensionTypeOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeOrderedByCreatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeOrderedByCreatedAtASC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndExtensionTypeOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeOrderedByCreatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndExtensionTypeOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeOrderedByUpdatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndExtensionTypeOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndExtensionTypeOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND extension_type = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndExtensionTypeOrderedByUpdatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndExtensionTypeOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndExtensionTypeOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndExtensionTypeOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndPublic = `-- name: FetchExtensionByIdentifierAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndPublicParams struct {
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndPublic(ctx context.Context, arg FetchExtensionByIdentifierAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndPublic,
		arg.Identifier,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndPublicAndStatus = `-- name: FetchExtensionByIdentifierAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndPublicAndStatusParams struct {
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndPublicAndStatus(ctx context.Context, arg FetchExtensionByIdentifierAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndPublicAndStatus,
		arg.Identifier,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndPublicOrderedByCreatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndPublicOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndPublicOrderedByCreatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndPublicOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndPublicOrderedByUpdatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndPublicOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndPublicOrderedByUpdatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndPublicOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepository = `-- name: FetchExtensionByIdentifierAndRepository :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepository(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepository,
		arg.Identifier,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionType = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionType :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionType(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionType,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublic = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublic(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublic,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatus = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatus(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatus,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatus = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatus(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatus,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtASCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND extension_type = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESCParams struct {
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndPublic = `-- name: FetchExtensionByIdentifierAndRepositoryAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndPublicParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndPublic(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndPublic,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndPublicAndStatus = `-- name: FetchExtensionByIdentifierAndRepositoryAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndPublicAndStatus(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndPublicAndStatus,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByCreatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndPublicOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByCreatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndPublicOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByUpdatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndPublicOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByUpdatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndPublicOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndStatus = `-- name: FetchExtensionByIdentifierAndRepositoryAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndStatusParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndStatus(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndStatus,
		arg.Identifier,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByCreatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndStatusOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByCreatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndStatusOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByUpdatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndStatusOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByUpdatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryAndStatusOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryOrderedByCreatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryOrderedByCreatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndRepositoryOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryOrderedByUpdatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndRepositoryOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndRepositoryOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND repository = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndRepositoryOrderedByUpdatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndRepositoryOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndRepositoryOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndRepositoryOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndStatus = `-- name: FetchExtensionByIdentifierAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndStatusParams struct {
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndStatus(ctx context.Context, arg FetchExtensionByIdentifierAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndStatus,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndStatusOrderedByCreatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndStatusOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndStatusOrderedByCreatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndStatusOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndStatusOrderedByUpdatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndStatusOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierAndStatusOrderedByUpdatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierAndStatusOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierOrderedByCreatedAtASC = `-- name: FetchExtensionByIdentifierOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierOrderedByCreatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierOrderedByCreatedAtASC, arg.Identifier, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierOrderedByCreatedAtDESC = `-- name: FetchExtensionByIdentifierOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierOrderedByCreatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierOrderedByCreatedAtDESC, arg.Identifier, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierOrderedByUpdatedAtASC = `-- name: FetchExtensionByIdentifierOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierOrderedByUpdatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByIdentifierOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierOrderedByUpdatedAtASC, arg.Identifier, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByIdentifierOrderedByUpdatedAtDESC = `-- name: FetchExtensionByIdentifierOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     identifier = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByIdentifierOrderedByUpdatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByIdentifierOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByIdentifierOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByIdentifierOrderedByUpdatedAtDESC, arg.Identifier, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByPublic = `-- name: FetchExtensionByPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     public = ?  
    LIMIT ?, ?
`

type FetchExtensionByPublicParams struct {
	Public bool  `json:"public"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByPublic(ctx context.Context, arg FetchExtensionByPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByPublic, arg.Public, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByPublicAndStatus = `-- name: FetchExtensionByPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByPublicAndStatusParams struct {
	Public bool  `json:"public"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByPublicAndStatus(ctx context.Context, arg FetchExtensionByPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByPublicAndStatus,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByPublicAndStatusOrderedByCreatedAtASCParams struct {
	Public bool  `json:"public"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByPublicAndStatusOrderedByCreatedAtASC,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Public bool  `json:"public"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByPublicAndStatusOrderedByCreatedAtDESC,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Public bool  `json:"public"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByPublicAndStatusOrderedByUpdatedAtASC,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Public bool  `json:"public"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByPublicOrderedByCreatedAtASCParams struct {
	Public bool  `json:"public"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByPublicOrderedByCreatedAtASC, arg.Public, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByPublicOrderedByCreatedAtDESCParams struct {
	Public bool  `json:"public"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByPublicOrderedByCreatedAtDESC, arg.Public, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByPublicOrderedByUpdatedAtASCParams struct {
	Public bool  `json:"public"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByPublicOrderedByUpdatedAtASC, arg.Public, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByPublicOrderedByUpdatedAtDESCParams struct {
	Public bool  `json:"public"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByPublicOrderedByUpdatedAtDESC, arg.Public, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepository = `-- name: FetchExtensionByRepository :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ?  
    LIMIT ?, ?
`

type FetchExtensionByRepositoryParams struct {
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepository(ctx context.Context, arg FetchExtensionByRepositoryParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepository, arg.Repository, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionType = `-- name: FetchExtensionByRepositoryAndExtensionType :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ?  
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionType(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionType,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndPublic = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndPublicParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndPublic(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndPublic,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatus = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatus(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatus,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndStatus = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndStatusParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndStatus(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndStatus,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeOrderedByCreatedAtASC = `-- name: FetchExtensionByRepositoryAndExtensionTypeOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeOrderedByCreatedAtASCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeOrderedByCreatedAtASC,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeOrderedByCreatedAtDESC = `-- name: FetchExtensionByRepositoryAndExtensionTypeOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeOrderedByCreatedAtDESCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeOrderedByCreatedAtDESC,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeOrderedByUpdatedAtASC = `-- name: FetchExtensionByRepositoryAndExtensionTypeOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeOrderedByUpdatedAtASCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeOrderedByUpdatedAtASC,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndExtensionTypeOrderedByUpdatedAtDESC = `-- name: FetchExtensionByRepositoryAndExtensionTypeOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND extension_type = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndExtensionTypeOrderedByUpdatedAtDESCParams struct {
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndExtensionTypeOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndExtensionTypeOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndExtensionTypeOrderedByUpdatedAtDESC,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndPublic = `-- name: FetchExtensionByRepositoryAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndPublicParams struct {
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndPublic(ctx context.Context, arg FetchExtensionByRepositoryAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndPublic,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndPublicAndStatus = `-- name: FetchExtensionByRepositoryAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndPublicAndStatusParams struct {
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndPublicAndStatus(ctx context.Context, arg FetchExtensionByRepositoryAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndPublicAndStatus,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByRepositoryAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByRepositoryAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByRepositoryAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByRepositoryAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndPublicOrderedByCreatedAtASCParams struct {
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndPublicOrderedByCreatedAtASC,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByRepositoryAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndPublicOrderedByCreatedAtDESCParams struct {
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndPublicOrderedByCreatedAtDESC,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByRepositoryAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndPublicOrderedByUpdatedAtASCParams struct {
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndPublicOrderedByUpdatedAtASC,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByRepositoryAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndPublicOrderedByUpdatedAtDESCParams struct {
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndPublicOrderedByUpdatedAtDESC,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndStatus = `-- name: FetchExtensionByRepositoryAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndStatusParams struct {
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndStatus(ctx context.Context, arg FetchExtensionByRepositoryAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndStatus,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByRepositoryAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndStatusOrderedByCreatedAtASCParams struct {
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndStatusOrderedByCreatedAtASC,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByRepositoryAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndStatusOrderedByCreatedAtDESCParams struct {
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndStatusOrderedByCreatedAtDESC,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByRepositoryAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndStatusOrderedByUpdatedAtASCParams struct {
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndStatusOrderedByUpdatedAtASC,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByRepositoryAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryAndStatusOrderedByUpdatedAtDESCParams struct {
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryAndStatusOrderedByUpdatedAtDESC,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryOrderedByCreatedAtASC = `-- name: FetchExtensionByRepositoryOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryOrderedByCreatedAtASCParams struct {
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryOrderedByCreatedAtASC, arg.Repository, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryOrderedByCreatedAtDESC = `-- name: FetchExtensionByRepositoryOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryOrderedByCreatedAtDESCParams struct {
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryOrderedByCreatedAtDESC, arg.Repository, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryOrderedByUpdatedAtASC = `-- name: FetchExtensionByRepositoryOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryOrderedByUpdatedAtASCParams struct {
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByRepositoryOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryOrderedByUpdatedAtASC, arg.Repository, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByRepositoryOrderedByUpdatedAtDESC = `-- name: FetchExtensionByRepositoryOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     repository = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByRepositoryOrderedByUpdatedAtDESCParams struct {
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByRepositoryOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByRepositoryOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByRepositoryOrderedByUpdatedAtDESC, arg.Repository, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByStatus = `-- name: FetchExtensionByStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchExtensionByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByStatus(ctx context.Context, arg FetchExtensionByStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByUUID = `-- name: FetchExtensionByUUID :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     uuid = ?
`

func (q *Queries) FetchExtensionByUUID(ctx context.Context, uuid string) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByUUIDForUpdate = `-- name: FetchExtensionByUUIDForUpdate :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchExtensionByUUIDForUpdate(ctx context.Context, uuid string) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersion = `-- name: FetchExtensionByVersion :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersion(ctx context.Context, arg FetchExtensionByVersionParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersion, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionType = `-- name: FetchExtensionByVersionAndExtensionType :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionType(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionType,
		arg.Version,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndPublic = `-- name: FetchExtensionByVersionAndExtensionTypeAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndPublicParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndPublic(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndPublic,
		arg.Version,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndPublicAndStatus = `-- name: FetchExtensionByVersionAndExtensionTypeAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndPublicAndStatus(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndPublicAndStatus,
		arg.Version,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByCreatedAtASCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndPublicOrderedByCreatedAtASC,
		arg.Version,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndPublicOrderedByCreatedAtDESC,
		arg.Version,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndPublicOrderedByUpdatedAtASC,
		arg.Version,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Public        bool  `json:"public"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndPublicOrderedByUpdatedAtDESC,
		arg.Version,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndStatus = `-- name: FetchExtensionByVersionAndExtensionTypeAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndStatusParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndStatus(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndStatus,
		arg.Version,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByCreatedAtASCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Status        int64 `json:"status"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndExtensionTypeOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeOrderedByCreatedAtASCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeOrderedByCreatedAtASC,
		arg.Version,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndExtensionTypeOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeOrderedByCreatedAtDESCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeOrderedByCreatedAtDESC,
		arg.Version,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndExtensionTypeOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeOrderedByUpdatedAtASCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeOrderedByUpdatedAtASC,
		arg.Version,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndExtensionTypeOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndExtensionTypeOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND extension_type = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndExtensionTypeOrderedByUpdatedAtDESCParams struct {
	Version       int64 `json:"version"`
	ExtensionType int64 `json:"extension_type"`
	Offset        int32 `json:"offset"`
	Limit         int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndExtensionTypeOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndExtensionTypeOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndExtensionTypeOrderedByUpdatedAtDESC,
		arg.Version,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifier = `-- name: FetchExtensionByVersionAndIdentifier :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifier(ctx context.Context, arg FetchExtensionByVersionAndIdentifierParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifier,
		arg.Version,
		arg.Identifier,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionType = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionType :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionType(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionType,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublic = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublic(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublic,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatus = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatus(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatus,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndPublicOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatus = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatus(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatus,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByCreatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByCreatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByUpdatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND extension_type = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByUpdatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndExtensionTypeOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndPublic = `-- name: FetchExtensionByVersionAndIdentifierAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndPublicParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndPublic(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndPublic,
		arg.Version,
		arg.Identifier,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndPublicAndStatus = `-- name: FetchExtensionByVersionAndIdentifierAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndPublicAndStatusParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndPublicAndStatus(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndPublicAndStatus,
		arg.Version,
		arg.Identifier,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndPublicOrderedByCreatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndPublicOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndPublicOrderedByCreatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndPublicOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndPublicOrderedByUpdatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndPublicOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndPublicOrderedByUpdatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndPublicOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepository = `-- name: FetchExtensionByVersionAndIdentifierAndRepository :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepository(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepository,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionType = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionType :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionType(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionType,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublic = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublic(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublic,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatus = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatus(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatus,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatus = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatus(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatus,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtASCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND extension_type = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Identifier    string `json:"identifier"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndPublic = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndPublic(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndPublic,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatus = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatus(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatus,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByCreatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByCreatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByUpdatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByUpdatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndPublicOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndStatus = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndStatus(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndStatus,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByCreatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByCreatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByUpdatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByUpdatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByCreatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByCreatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByUpdatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndRepositoryOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND repository = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByUpdatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndRepositoryOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndRepositoryOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndStatus = `-- name: FetchExtensionByVersionAndIdentifierAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndStatusParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndStatus(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndStatus,
		arg.Version,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndStatusOrderedByCreatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndStatusOrderedByCreatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndStatusOrderedByUpdatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierAndStatusOrderedByUpdatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierOrderedByCreatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierOrderedByCreatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierOrderedByCreatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierOrderedByCreatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndIdentifierOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierOrderedByUpdatedAtASCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierOrderedByUpdatedAtASC,
		arg.Version,
		arg.Identifier,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndIdentifierOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndIdentifierOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND identifier = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndIdentifierOrderedByUpdatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndIdentifierOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndIdentifierOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndIdentifierOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Identifier,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndPublic = `-- name: FetchExtensionByVersionAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndPublicParams struct {
	Version int64 `json:"version"`
	Public  bool  `json:"public"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndPublic(ctx context.Context, arg FetchExtensionByVersionAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndPublic,
		arg.Version,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndPublicAndStatus = `-- name: FetchExtensionByVersionAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndPublicAndStatusParams struct {
	Version int64 `json:"version"`
	Public  bool  `json:"public"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndPublicAndStatus(ctx context.Context, arg FetchExtensionByVersionAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndPublicAndStatus,
		arg.Version,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Public  bool  `json:"public"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Public  bool  `json:"public"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Public  bool  `json:"public"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Public  bool  `json:"public"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndPublicOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Public  bool  `json:"public"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndPublicOrderedByCreatedAtASC,
		arg.Version,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndPublicOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Public  bool  `json:"public"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndPublicOrderedByCreatedAtDESC,
		arg.Version,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndPublicOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Public  bool  `json:"public"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndPublicOrderedByUpdatedAtASC,
		arg.Version,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndPublicOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Public  bool  `json:"public"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndPublicOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepository = `-- name: FetchExtensionByVersionAndRepository :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepository(ctx context.Context, arg FetchExtensionByVersionAndRepositoryParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepository,
		arg.Version,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionType = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionType :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionType(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionType,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublic = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublic(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublic,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatus = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatus(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatus,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtASC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByCreatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtASC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Public        bool   `json:"public"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndPublicOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatus = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatus(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatus,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Status        int64  `json:"status"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByCreatedAtASCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByCreatedAtASC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByCreatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByCreatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByUpdatedAtASCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByUpdatedAtASC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND extension_type = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESCParams struct {
	Version       int64  `json:"version"`
	Repository    string `json:"repository"`
	ExtensionType int64  `json:"extension_type"`
	Offset        int32  `json:"offset"`
	Limit         int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndExtensionTypeOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.ExtensionType,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndPublic = `-- name: FetchExtensionByVersionAndRepositoryAndPublic :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND public = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndPublicParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndPublic(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndPublicParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndPublic,
		arg.Version,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndPublicAndStatus = `-- name: FetchExtensionByVersionAndRepositoryAndPublicAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND public = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndPublicAndStatusParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndPublicAndStatus(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndPublicAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndPublicAndStatus,
		arg.Version,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND public = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByCreatedAtASCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND public = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND public = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND public = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndPublicAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.Public,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndPublicOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndPublicOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND public = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndPublicOrderedByCreatedAtASCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndPublicOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndPublicOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndPublicOrderedByCreatedAtASC,
		arg.Version,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndPublicOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndPublicOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND public = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndPublicOrderedByCreatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndPublicOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndPublicOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndPublicOrderedByCreatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndPublicOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndPublicOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND public = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndPublicOrderedByUpdatedAtASCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndPublicOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndPublicOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndPublicOrderedByUpdatedAtASC,
		arg.Version,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndPublicOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndPublicOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND public = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndPublicOrderedByUpdatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Public     bool   `json:"public"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndPublicOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndPublicOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndPublicOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.Public,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndStatus = `-- name: FetchExtensionByVersionAndRepositoryAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndStatusParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndStatus(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndStatus,
		arg.Version,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndStatusOrderedByCreatedAtASCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndStatusOrderedByCreatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndStatusOrderedByUpdatedAtASCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryAndStatusOrderedByUpdatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryOrderedByCreatedAtASCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryOrderedByCreatedAtASC,
		arg.Version,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryOrderedByCreatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryOrderedByCreatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndRepositoryOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryOrderedByUpdatedAtASCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryOrderedByUpdatedAtASC,
		arg.Version,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndRepositoryOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndRepositoryOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND repository = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndRepositoryOrderedByUpdatedAtDESCParams struct {
	Version    int64  `json:"version"`
	Repository string `json:"repository"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndRepositoryOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndRepositoryOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndRepositoryOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Repository,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndStatus = `-- name: FetchExtensionByVersionAndStatus :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionByVersionAndStatusParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndStatus(ctx context.Context, arg FetchExtensionByVersionAndStatusParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndStatus,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndStatusOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndStatusOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndStatusOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndStatusOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndStatusOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionAndStatusOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionAndStatusOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionAndStatusOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionOrderedByCreatedAtASC = `-- name: FetchExtensionByVersionOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionByVersionOrderedByCreatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionOrderedByCreatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionOrderedByCreatedAtDESC = `-- name: FetchExtensionByVersionOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionByVersionOrderedByCreatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionOrderedByCreatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionOrderedByUpdatedAtASC = `-- name: FetchExtensionByVersionOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionByVersionOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionByVersionOrderedByUpdatedAtASCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionOrderedByUpdatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionByVersionOrderedByUpdatedAtDESC = `-- name: FetchExtensionByVersionOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
     version = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionByVersionOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionByVersionOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionByVersionOrderedByUpdatedAtDESCParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionByVersionOrderedByUpdatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionExecutionByStatus = `-- name: FetchExtensionExecutionByStatus :many
SELECT uuid, extension_uuid, extension_version_uuid, project_extension_uuid, project_uuid, project_version_uuid, executed_by_uuid, metadata, status, status_msg, created_at, updated_at FROM extension_execution
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchExtensionExecutionByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionExecutionByStatus(ctx context.Context, arg FetchExtensionExecutionByStatusParams) ([]ExtensionExecution, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionExecutionByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionExecution
	for rows.Next() {
		var i ExtensionExecution
		if err := rows.Scan(
			&i.UUID,
			&i.ExtensionUUID,
			&i.ExtensionVersionUUID,
			&i.ProjectExtensionUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ExecutedByUUID,
			&i.Metadata,
			&i.Status,
			&i.StatusMsg,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionExecutionByStatusOrderedByCreatedAtASC = `-- name: FetchExtensionExecutionByStatusOrderedByCreatedAtASC :many
SELECT uuid, extension_uuid, extension_version_uuid, project_extension_uuid, project_uuid, project_version_uuid, executed_by_uuid, metadata, status, status_msg, created_at, updated_at FROM extension_execution
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionExecutionByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionExecutionByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionExecutionByStatusOrderedByCreatedAtASCParams) ([]ExtensionExecution, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionExecutionByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionExecution
	for rows.Next() {
		var i ExtensionExecution
		if err := rows.Scan(
			&i.UUID,
			&i.ExtensionUUID,
			&i.ExtensionVersionUUID,
			&i.ProjectExtensionUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ExecutedByUUID,
			&i.Metadata,
			&i.Status,
			&i.StatusMsg,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionExecutionByStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionExecutionByStatusOrderedByCreatedAtDESC :many
SELECT uuid, extension_uuid, extension_version_uuid, project_extension_uuid, project_uuid, project_version_uuid, executed_by_uuid, metadata, status, status_msg, created_at, updated_at FROM extension_execution
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionExecutionByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionExecutionByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionExecutionByStatusOrderedByCreatedAtDESCParams) ([]ExtensionExecution, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionExecutionByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionExecution
	for rows.Next() {
		var i ExtensionExecution
		if err := rows.Scan(
			&i.UUID,
			&i.ExtensionUUID,
			&i.ExtensionVersionUUID,
			&i.ProjectExtensionUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ExecutedByUUID,
			&i.Metadata,
			&i.Status,
			&i.StatusMsg,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionExecutionByStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionExecutionByStatusOrderedByUpdatedAtASC :many
SELECT uuid, extension_uuid, extension_version_uuid, project_extension_uuid, project_uuid, project_version_uuid, executed_by_uuid, metadata, status, status_msg, created_at, updated_at FROM extension_execution
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionExecutionByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionExecutionByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionExecutionByStatusOrderedByUpdatedAtASCParams) ([]ExtensionExecution, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionExecutionByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionExecution
	for rows.Next() {
		var i ExtensionExecution
		if err := rows.Scan(
			&i.UUID,
			&i.ExtensionUUID,
			&i.ExtensionVersionUUID,
			&i.ProjectExtensionUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ExecutedByUUID,
			&i.Metadata,
			&i.Status,
			&i.StatusMsg,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionExecutionByStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionExecutionByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, extension_uuid, extension_version_uuid, project_extension_uuid, project_uuid, project_version_uuid, executed_by_uuid, metadata, status, status_msg, created_at, updated_at FROM extension_execution
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionExecutionByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionExecutionByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionExecutionByStatusOrderedByUpdatedAtDESCParams) ([]ExtensionExecution, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionExecutionByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionExecution
	for rows.Next() {
		var i ExtensionExecution
		if err := rows.Scan(
			&i.UUID,
			&i.ExtensionUUID,
			&i.ExtensionVersionUUID,
			&i.ProjectExtensionUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ExecutedByUUID,
			&i.Metadata,
			&i.Status,
			&i.StatusMsg,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionExecutionByUUID = `-- name: FetchExtensionExecutionByUUID :many
SELECT uuid, extension_uuid, extension_version_uuid, project_extension_uuid, project_uuid, project_version_uuid, executed_by_uuid, metadata, status, status_msg, created_at, updated_at FROM extension_execution
WHERE 
     uuid = ?
`

func (q *Queries) FetchExtensionExecutionByUUID(ctx context.Context, uuid string) ([]ExtensionExecution, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionExecutionByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionExecution
	for rows.Next() {
		var i ExtensionExecution
		if err := rows.Scan(
			&i.UUID,
			&i.ExtensionUUID,
			&i.ExtensionVersionUUID,
			&i.ProjectExtensionUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ExecutedByUUID,
			&i.Metadata,
			&i.Status,
			&i.StatusMsg,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionExecutionByUUIDForUpdate = `-- name: FetchExtensionExecutionByUUIDForUpdate :many
SELECT uuid, extension_uuid, extension_version_uuid, project_extension_uuid, project_uuid, project_version_uuid, executed_by_uuid, metadata, status, status_msg, created_at, updated_at FROM extension_execution
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchExtensionExecutionByUUIDForUpdate(ctx context.Context, uuid string) ([]ExtensionExecution, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionExecutionByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionExecution
	for rows.Next() {
		var i ExtensionExecution
		if err := rows.Scan(
			&i.UUID,
			&i.ExtensionUUID,
			&i.ExtensionVersionUUID,
			&i.ProjectExtensionUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ExecutedByUUID,
			&i.Metadata,
			&i.Status,
			&i.StatusMsg,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByStatus = `-- name: FetchExtensionVersionByStatus :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchExtensionVersionByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByStatus(ctx context.Context, arg FetchExtensionVersionByStatusParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByStatusOrderedByCreatedAtASC = `-- name: FetchExtensionVersionByStatusOrderedByCreatedAtASC :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionVersionByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionVersionByStatusOrderedByCreatedAtASCParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionVersionByStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionVersionByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionVersionByStatusOrderedByCreatedAtDESCParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionVersionByStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionVersionByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionVersionByStatusOrderedByUpdatedAtASCParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionVersionByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionVersionByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionVersionByStatusOrderedByUpdatedAtDESCParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByUUID = `-- name: FetchExtensionVersionByUUID :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     uuid = ?
`

func (q *Queries) FetchExtensionVersionByUUID(ctx context.Context, uuid string) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByUUIDForUpdate = `-- name: FetchExtensionVersionByUUIDForUpdate :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchExtensionVersionByUUIDForUpdate(ctx context.Context, uuid string) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByVersion = `-- name: FetchExtensionVersionByVersion :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     version = ?  
    LIMIT ?, ?
`

type FetchExtensionVersionByVersionParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByVersion(ctx context.Context, arg FetchExtensionVersionByVersionParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByVersion, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByVersionAndStatus = `-- name: FetchExtensionVersionByVersionAndStatus :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     version = ? AND status = ?  
    LIMIT ?, ?
`

type FetchExtensionVersionByVersionAndStatusParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByVersionAndStatus(ctx context.Context, arg FetchExtensionVersionByVersionAndStatusParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByVersionAndStatus,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByVersionAndStatusOrderedByCreatedAtASC = `-- name: FetchExtensionVersionByVersionAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionVersionByVersionAndStatusOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByVersionAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionVersionByVersionAndStatusOrderedByCreatedAtASCParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByVersionAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByVersionAndStatusOrderedByCreatedAtDESC = `-- name: FetchExtensionVersionByVersionAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionVersionByVersionAndStatusOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByVersionAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionVersionByVersionAndStatusOrderedByCreatedAtDESCParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByVersionAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByVersionAndStatusOrderedByUpdatedAtASC = `-- name: FetchExtensionVersionByVersionAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionVersionByVersionAndStatusOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByVersionAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionVersionByVersionAndStatusOrderedByUpdatedAtASCParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByVersionAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByVersionAndStatusOrderedByUpdatedAtDESC = `-- name: FetchExtensionVersionByVersionAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionVersionByVersionAndStatusOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByVersionAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionVersionByVersionAndStatusOrderedByUpdatedAtDESCParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByVersionAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByVersionOrderedByCreatedAtASC = `-- name: FetchExtensionVersionByVersionOrderedByCreatedAtASC :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     version = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchExtensionVersionByVersionOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByVersionOrderedByCreatedAtASC(ctx context.Context, arg FetchExtensionVersionByVersionOrderedByCreatedAtASCParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByVersionOrderedByCreatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByVersionOrderedByCreatedAtDESC = `-- name: FetchExtensionVersionByVersionOrderedByCreatedAtDESC :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     version = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchExtensionVersionByVersionOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByVersionOrderedByCreatedAtDESC(ctx context.Context, arg FetchExtensionVersionByVersionOrderedByCreatedAtDESCParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByVersionOrderedByCreatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByVersionOrderedByUpdatedAtASC = `-- name: FetchExtensionVersionByVersionOrderedByUpdatedAtASC :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     version = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchExtensionVersionByVersionOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByVersionOrderedByUpdatedAtASC(ctx context.Context, arg FetchExtensionVersionByVersionOrderedByUpdatedAtASCParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByVersionOrderedByUpdatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchExtensionVersionByVersionOrderedByUpdatedAtDESC = `-- name: FetchExtensionVersionByVersionOrderedByUpdatedAtDESC :many
SELECT uuid, version, extension_uuid, display_version, description, repository_tag, configuration_entity, execution_mode, review_status, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension_version
WHERE 
     version = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchExtensionVersionByVersionOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchExtensionVersionByVersionOrderedByUpdatedAtDESC(ctx context.Context, arg FetchExtensionVersionByVersionOrderedByUpdatedAtDESCParams) ([]ExtensionVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchExtensionVersionByVersionOrderedByUpdatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExtensionVersion
	for rows.Next() {
		var i ExtensionVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ExtensionUUID,
			&i.DisplayVersion,
			&i.Description,
			&i.RepositoryTag,
			&i.ConfigurationEntity,
			&i.ExecutionMode,
			&i.ReviewStatus,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByStatus = `-- name: FetchMembershipByStatus :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchMembershipByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByStatus(ctx context.Context, arg FetchMembershipByStatusParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByStatusOrderedByCreatedAtASC = `-- name: FetchMembershipByStatusOrderedByCreatedAtASC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchMembershipByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchMembershipByStatusOrderedByCreatedAtASCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByStatusOrderedByCreatedAtDESC = `-- name: FetchMembershipByStatusOrderedByCreatedAtDESC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchMembershipByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchMembershipByStatusOrderedByCreatedAtDESCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByStatusOrderedByStartDateASC = `-- name: FetchMembershipByStatusOrderedByStartDateASC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     status = ?  
    ORDER BY start_date ASC
    LIMIT ?, ?
`

type FetchMembershipByStatusOrderedByStartDateASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByStatusOrderedByStartDateASC(ctx context.Context, arg FetchMembershipByStatusOrderedByStartDateASCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByStatusOrderedByStartDateASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByStatusOrderedByStartDateDESC = `-- name: FetchMembershipByStatusOrderedByStartDateDESC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     status = ?  
    ORDER BY start_date DESC
    LIMIT ?, ?
`

type FetchMembershipByStatusOrderedByStartDateDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByStatusOrderedByStartDateDESC(ctx context.Context, arg FetchMembershipByStatusOrderedByStartDateDESCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByStatusOrderedByStartDateDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByStatusOrderedByUpdatedAtASC = `-- name: FetchMembershipByStatusOrderedByUpdatedAtASC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchMembershipByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchMembershipByStatusOrderedByUpdatedAtASCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByStatusOrderedByUpdatedAtDESC = `-- name: FetchMembershipByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchMembershipByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchMembershipByStatusOrderedByUpdatedAtDESCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByType = `-- name: FetchMembershipByType :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ?  
    LIMIT ?, ?
`

type FetchMembershipByTypeParams struct {
	Type   int64 `json:"type"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByType(ctx context.Context, arg FetchMembershipByTypeParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByType, arg.Type, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeAndStatus = `-- name: FetchMembershipByTypeAndStatus :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ? AND status = ?  
    LIMIT ?, ?
`

type FetchMembershipByTypeAndStatusParams struct {
	Type   int64 `json:"type"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeAndStatus(ctx context.Context, arg FetchMembershipByTypeAndStatusParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeAndStatus,
		arg.Type,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeAndStatusOrderedByCreatedAtASC = `-- name: FetchMembershipByTypeAndStatusOrderedByCreatedAtASC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchMembershipByTypeAndStatusOrderedByCreatedAtASCParams struct {
	Type   int64 `json:"type"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchMembershipByTypeAndStatusOrderedByCreatedAtASCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeAndStatusOrderedByCreatedAtASC,
		arg.Type,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeAndStatusOrderedByCreatedAtDESC = `-- name: FetchMembershipByTypeAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchMembershipByTypeAndStatusOrderedByCreatedAtDESCParams struct {
	Type   int64 `json:"type"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchMembershipByTypeAndStatusOrderedByCreatedAtDESCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeAndStatusOrderedByCreatedAtDESC,
		arg.Type,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeAndStatusOrderedByStartDateASC = `-- name: FetchMembershipByTypeAndStatusOrderedByStartDateASC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ? AND status = ?  
    ORDER BY start_date ASC
    LIMIT ?, ?
`

type FetchMembershipByTypeAndStatusOrderedByStartDateASCParams struct {
	Type   int64 `json:"type"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeAndStatusOrderedByStartDateASC(ctx context.Context, arg FetchMembershipByTypeAndStatusOrderedByStartDateASCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeAndStatusOrderedByStartDateASC,
		arg.Type,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeAndStatusOrderedByStartDateDESC = `-- name: FetchMembershipByTypeAndStatusOrderedByStartDateDESC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ? AND status = ?  
    ORDER BY start_date DESC
    LIMIT ?, ?
`

type FetchMembershipByTypeAndStatusOrderedByStartDateDESCParams struct {
	Type   int64 `json:"type"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeAndStatusOrderedByStartDateDESC(ctx context.Context, arg FetchMembershipByTypeAndStatusOrderedByStartDateDESCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeAndStatusOrderedByStartDateDESC,
		arg.Type,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeAndStatusOrderedByUpdatedAtASC = `-- name: FetchMembershipByTypeAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchMembershipByTypeAndStatusOrderedByUpdatedAtASCParams struct {
	Type   int64 `json:"type"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchMembershipByTypeAndStatusOrderedByUpdatedAtASCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeAndStatusOrderedByUpdatedAtASC,
		arg.Type,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeAndStatusOrderedByUpdatedAtDESC = `-- name: FetchMembershipByTypeAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchMembershipByTypeAndStatusOrderedByUpdatedAtDESCParams struct {
	Type   int64 `json:"type"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchMembershipByTypeAndStatusOrderedByUpdatedAtDESCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeAndStatusOrderedByUpdatedAtDESC,
		arg.Type,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeOrderedByCreatedAtASC = `-- name: FetchMembershipByTypeOrderedByCreatedAtASC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchMembershipByTypeOrderedByCreatedAtASCParams struct {
	Type   int64 `json:"type"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeOrderedByCreatedAtASC(ctx context.Context, arg FetchMembershipByTypeOrderedByCreatedAtASCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeOrderedByCreatedAtASC, arg.Type, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeOrderedByCreatedAtDESC = `-- name: FetchMembershipByTypeOrderedByCreatedAtDESC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchMembershipByTypeOrderedByCreatedAtDESCParams struct {
	Type   int64 `json:"type"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeOrderedByCreatedAtDESC(ctx context.Context, arg FetchMembershipByTypeOrderedByCreatedAtDESCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeOrderedByCreatedAtDESC, arg.Type, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeOrderedByStartDateASC = `-- name: FetchMembershipByTypeOrderedByStartDateASC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ?  
    ORDER BY start_date ASC
    LIMIT ?, ?
`

type FetchMembershipByTypeOrderedByStartDateASCParams struct {
	Type   int64 `json:"type"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeOrderedByStartDateASC(ctx context.Context, arg FetchMembershipByTypeOrderedByStartDateASCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeOrderedByStartDateASC, arg.Type, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeOrderedByStartDateDESC = `-- name: FetchMembershipByTypeOrderedByStartDateDESC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ?  
    ORDER BY start_date DESC
    LIMIT ?, ?
`

type FetchMembershipByTypeOrderedByStartDateDESCParams struct {
	Type   int64 `json:"type"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeOrderedByStartDateDESC(ctx context.Context, arg FetchMembershipByTypeOrderedByStartDateDESCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeOrderedByStartDateDESC, arg.Type, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeOrderedByUpdatedAtASC = `-- name: FetchMembershipByTypeOrderedByUpdatedAtASC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchMembershipByTypeOrderedByUpdatedAtASCParams struct {
	Type   int64 `json:"type"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeOrderedByUpdatedAtASC(ctx context.Context, arg FetchMembershipByTypeOrderedByUpdatedAtASCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeOrderedByUpdatedAtASC, arg.Type, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByTypeOrderedByUpdatedAtDESC = `-- name: FetchMembershipByTypeOrderedByUpdatedAtDESC :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     type = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchMembershipByTypeOrderedByUpdatedAtDESCParams struct {
	Type   int64 `json:"type"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchMembershipByTypeOrderedByUpdatedAtDESC(ctx context.Context, arg FetchMembershipByTypeOrderedByUpdatedAtDESCParams) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByTypeOrderedByUpdatedAtDESC, arg.Type, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByUUID = `-- name: FetchMembershipByUUID :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     uuid = ?
`

func (q *Queries) FetchMembershipByUUID(ctx context.Context, uuid string) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchMembershipByUUIDForUpdate = `-- name: FetchMembershipByUUIDForUpdate :many
SELECT uuid, owner_uuid, type, start_date, billing_metadata, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM membership
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchMembershipByUUIDForUpdate(ctx context.Context, uuid string) ([]Membership, error) {
	rows, err := q.db.QueryContext(ctx, fetchMembershipByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Membership
	for rows.Next() {
		var i Membership
		if err := rows.Scan(
			&i.UUID,
			&i.OwnerUUID,
			&i.Type,
			&i.StartDate,
			&i.BillingMetadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByStatus = `-- name: FetchOrganizationByStatus :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchOrganizationByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByStatus(ctx context.Context, arg FetchOrganizationByStatusParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByStatusOrderedByCreatedAtASC = `-- name: FetchOrganizationByStatusOrderedByCreatedAtASC :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchOrganizationByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchOrganizationByStatusOrderedByCreatedAtASCParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByStatusOrderedByCreatedAtDESC = `-- name: FetchOrganizationByStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchOrganizationByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchOrganizationByStatusOrderedByCreatedAtDESCParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByStatusOrderedByUpdatedAtASC = `-- name: FetchOrganizationByStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchOrganizationByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchOrganizationByStatusOrderedByUpdatedAtASCParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByStatusOrderedByUpdatedAtDESC = `-- name: FetchOrganizationByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchOrganizationByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchOrganizationByStatusOrderedByUpdatedAtDESCParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByUUID = `-- name: FetchOrganizationByUUID :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     uuid = ?
`

func (q *Queries) FetchOrganizationByUUID(ctx context.Context, uuid string) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByUUIDForUpdate = `-- name: FetchOrganizationByUUIDForUpdate :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchOrganizationByUUIDForUpdate(ctx context.Context, uuid string) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByVersion = `-- name: FetchOrganizationByVersion :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     version = ?  
    LIMIT ?, ?
`

type FetchOrganizationByVersionParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByVersion(ctx context.Context, arg FetchOrganizationByVersionParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByVersion, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByVersionAndStatus = `-- name: FetchOrganizationByVersionAndStatus :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     version = ? AND status = ?  
    LIMIT ?, ?
`

type FetchOrganizationByVersionAndStatusParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByVersionAndStatus(ctx context.Context, arg FetchOrganizationByVersionAndStatusParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByVersionAndStatus,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByVersionAndStatusOrderedByCreatedAtASC = `-- name: FetchOrganizationByVersionAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchOrganizationByVersionAndStatusOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByVersionAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchOrganizationByVersionAndStatusOrderedByCreatedAtASCParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByVersionAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByVersionAndStatusOrderedByCreatedAtDESC = `-- name: FetchOrganizationByVersionAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchOrganizationByVersionAndStatusOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByVersionAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchOrganizationByVersionAndStatusOrderedByCreatedAtDESCParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByVersionAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByVersionAndStatusOrderedByUpdatedAtASC = `-- name: FetchOrganizationByVersionAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchOrganizationByVersionAndStatusOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByVersionAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchOrganizationByVersionAndStatusOrderedByUpdatedAtASCParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByVersionAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByVersionAndStatusOrderedByUpdatedAtDESC = `-- name: FetchOrganizationByVersionAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchOrganizationByVersionAndStatusOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByVersionAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchOrganizationByVersionAndStatusOrderedByUpdatedAtDESCParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByVersionAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByVersionOrderedByCreatedAtASC = `-- name: FetchOrganizationByVersionOrderedByCreatedAtASC :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     version = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchOrganizationByVersionOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByVersionOrderedByCreatedAtASC(ctx context.Context, arg FetchOrganizationByVersionOrderedByCreatedAtASCParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByVersionOrderedByCreatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByVersionOrderedByCreatedAtDESC = `-- name: FetchOrganizationByVersionOrderedByCreatedAtDESC :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     version = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchOrganizationByVersionOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByVersionOrderedByCreatedAtDESC(ctx context.Context, arg FetchOrganizationByVersionOrderedByCreatedAtDESCParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByVersionOrderedByCreatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByVersionOrderedByUpdatedAtASC = `-- name: FetchOrganizationByVersionOrderedByUpdatedAtASC :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     version = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchOrganizationByVersionOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByVersionOrderedByUpdatedAtASC(ctx context.Context, arg FetchOrganizationByVersionOrderedByUpdatedAtASCParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByVersionOrderedByUpdatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchOrganizationByVersionOrderedByUpdatedAtDESC = `-- name: FetchOrganizationByVersionOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
     version = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchOrganizationByVersionOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchOrganizationByVersionOrderedByUpdatedAtDESC(ctx context.Context, arg FetchOrganizationByVersionOrderedByUpdatedAtDESCParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, fetchOrganizationByVersionOrderedByUpdatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByName = `-- name: FetchProjectByName :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     name = ?  
    LIMIT ?, ?
`

type FetchProjectByNameParams struct {
	Name   string `json:"name"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchProjectByName(ctx context.Context, arg FetchProjectByNameParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByName, arg.Name, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByNameAndStatus = `-- name: FetchProjectByNameAndStatus :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     name = ? AND status = ?  
    LIMIT ?, ?
`

type FetchProjectByNameAndStatusParams struct {
	Name   string `json:"name"`
	Status int64  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchProjectByNameAndStatus(ctx context.Context, arg FetchProjectByNameAndStatusParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByNameAndStatus,
		arg.Name,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByNameAndStatusOrderedByCreatedAtASC = `-- name: FetchProjectByNameAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     name = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectByNameAndStatusOrderedByCreatedAtASCParams struct {
	Name   string `json:"name"`
	Status int64  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchProjectByNameAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectByNameAndStatusOrderedByCreatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByNameAndStatusOrderedByCreatedAtASC,
		arg.Name,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByNameAndStatusOrderedByCreatedAtDESC = `-- name: FetchProjectByNameAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     name = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectByNameAndStatusOrderedByCreatedAtDESCParams struct {
	Name   string `json:"name"`
	Status int64  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchProjectByNameAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectByNameAndStatusOrderedByCreatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByNameAndStatusOrderedByCreatedAtDESC,
		arg.Name,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByNameAndStatusOrderedByUpdatedAtASC = `-- name: FetchProjectByNameAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     name = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectByNameAndStatusOrderedByUpdatedAtASCParams struct {
	Name   string `json:"name"`
	Status int64  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchProjectByNameAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectByNameAndStatusOrderedByUpdatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByNameAndStatusOrderedByUpdatedAtASC,
		arg.Name,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByNameAndStatusOrderedByUpdatedAtDESC = `-- name: FetchProjectByNameAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     name = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectByNameAndStatusOrderedByUpdatedAtDESCParams struct {
	Name   string `json:"name"`
	Status int64  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchProjectByNameAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectByNameAndStatusOrderedByUpdatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByNameAndStatusOrderedByUpdatedAtDESC,
		arg.Name,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByNameOrderedByCreatedAtASC = `-- name: FetchProjectByNameOrderedByCreatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     name = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectByNameOrderedByCreatedAtASCParams struct {
	Name   string `json:"name"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchProjectByNameOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectByNameOrderedByCreatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByNameOrderedByCreatedAtASC, arg.Name, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByNameOrderedByCreatedAtDESC = `-- name: FetchProjectByNameOrderedByCreatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     name = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectByNameOrderedByCreatedAtDESCParams struct {
	Name   string `json:"name"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchProjectByNameOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectByNameOrderedByCreatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByNameOrderedByCreatedAtDESC, arg.Name, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByNameOrderedByUpdatedAtASC = `-- name: FetchProjectByNameOrderedByUpdatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     name = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectByNameOrderedByUpdatedAtASCParams struct {
	Name   string `json:"name"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchProjectByNameOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectByNameOrderedByUpdatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByNameOrderedByUpdatedAtASC, arg.Name, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByNameOrderedByUpdatedAtDESC = `-- name: FetchProjectByNameOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     name = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectByNameOrderedByUpdatedAtDESCParams struct {
	Name   string `json:"name"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchProjectByNameOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectByNameOrderedByUpdatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByNameOrderedByUpdatedAtDESC, arg.Name, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByStatus = `-- name: FetchProjectByStatus :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchProjectByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchProjectByStatus(ctx context.Context, arg FetchProjectByStatusParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByStatusOrderedByCreatedAtASC = `-- name: FetchProjectByStatusOrderedByCreatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchProjectByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectByStatusOrderedByCreatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByStatusOrderedByCreatedAtDESC = `-- name: FetchProjectByStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchProjectByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectByStatusOrderedByCreatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByStatusOrderedByUpdatedAtASC = `-- name: FetchProjectByStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchProjectByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectByStatusOrderedByUpdatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByStatusOrderedByUpdatedAtDESC = `-- name: FetchProjectByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchProjectByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectByStatusOrderedByUpdatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByUUID = `-- name: FetchProjectByUUID :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     uuid = ?
`

func (q *Queries) FetchProjectByUUID(ctx context.Context, uuid string) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByUUIDForUpdate = `-- name: FetchProjectByUUIDForUpdate :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchProjectByUUIDForUpdate(ctx context.Context, uuid string) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersion = `-- name: FetchProjectByVersion :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ?  
    LIMIT ?, ?
`

type FetchProjectByVersionParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectByVersion(ctx context.Context, arg FetchProjectByVersionParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersion, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndName = `-- name: FetchProjectByVersionAndName :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND name = ?  
    LIMIT ?, ?
`

type FetchProjectByVersionAndNameParams struct {
	Version int64  `json:"version"`
	Name    string `json:"name"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndName(ctx context.Context, arg FetchProjectByVersionAndNameParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndName,
		arg.Version,
		arg.Name,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndNameAndStatus = `-- name: FetchProjectByVersionAndNameAndStatus :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND name = ? AND status = ?  
    LIMIT ?, ?
`

type FetchProjectByVersionAndNameAndStatusParams struct {
	Version int64  `json:"version"`
	Name    string `json:"name"`
	Status  int64  `json:"status"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndNameAndStatus(ctx context.Context, arg FetchProjectByVersionAndNameAndStatusParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndNameAndStatus,
		arg.Version,
		arg.Name,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndNameAndStatusOrderedByCreatedAtASC = `-- name: FetchProjectByVersionAndNameAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND name = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectByVersionAndNameAndStatusOrderedByCreatedAtASCParams struct {
	Version int64  `json:"version"`
	Name    string `json:"name"`
	Status  int64  `json:"status"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndNameAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectByVersionAndNameAndStatusOrderedByCreatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndNameAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Name,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndNameAndStatusOrderedByCreatedAtDESC = `-- name: FetchProjectByVersionAndNameAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND name = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectByVersionAndNameAndStatusOrderedByCreatedAtDESCParams struct {
	Version int64  `json:"version"`
	Name    string `json:"name"`
	Status  int64  `json:"status"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndNameAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectByVersionAndNameAndStatusOrderedByCreatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndNameAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Name,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndNameAndStatusOrderedByUpdatedAtASC = `-- name: FetchProjectByVersionAndNameAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND name = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectByVersionAndNameAndStatusOrderedByUpdatedAtASCParams struct {
	Version int64  `json:"version"`
	Name    string `json:"name"`
	Status  int64  `json:"status"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndNameAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectByVersionAndNameAndStatusOrderedByUpdatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndNameAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Name,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndNameAndStatusOrderedByUpdatedAtDESC = `-- name: FetchProjectByVersionAndNameAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND name = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectByVersionAndNameAndStatusOrderedByUpdatedAtDESCParams struct {
	Version int64  `json:"version"`
	Name    string `json:"name"`
	Status  int64  `json:"status"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndNameAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectByVersionAndNameAndStatusOrderedByUpdatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndNameAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Name,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndNameOrderedByCreatedAtASC = `-- name: FetchProjectByVersionAndNameOrderedByCreatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND name = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectByVersionAndNameOrderedByCreatedAtASCParams struct {
	Version int64  `json:"version"`
	Name    string `json:"name"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndNameOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectByVersionAndNameOrderedByCreatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndNameOrderedByCreatedAtASC,
		arg.Version,
		arg.Name,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndNameOrderedByCreatedAtDESC = `-- name: FetchProjectByVersionAndNameOrderedByCreatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND name = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectByVersionAndNameOrderedByCreatedAtDESCParams struct {
	Version int64  `json:"version"`
	Name    string `json:"name"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndNameOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectByVersionAndNameOrderedByCreatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndNameOrderedByCreatedAtDESC,
		arg.Version,
		arg.Name,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndNameOrderedByUpdatedAtASC = `-- name: FetchProjectByVersionAndNameOrderedByUpdatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND name = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectByVersionAndNameOrderedByUpdatedAtASCParams struct {
	Version int64  `json:"version"`
	Name    string `json:"name"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndNameOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectByVersionAndNameOrderedByUpdatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndNameOrderedByUpdatedAtASC,
		arg.Version,
		arg.Name,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndNameOrderedByUpdatedAtDESC = `-- name: FetchProjectByVersionAndNameOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND name = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectByVersionAndNameOrderedByUpdatedAtDESCParams struct {
	Version int64  `json:"version"`
	Name    string `json:"name"`
	Offset  int32  `json:"offset"`
	Limit   int32  `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndNameOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectByVersionAndNameOrderedByUpdatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndNameOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Name,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndStatus = `-- name: FetchProjectByVersionAndStatus :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND status = ?  
    LIMIT ?, ?
`

type FetchProjectByVersionAndStatusParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndStatus(ctx context.Context, arg FetchProjectByVersionAndStatusParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndStatus,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndStatusOrderedByCreatedAtASC = `-- name: FetchProjectByVersionAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectByVersionAndStatusOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectByVersionAndStatusOrderedByCreatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndStatusOrderedByCreatedAtDESC = `-- name: FetchProjectByVersionAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectByVersionAndStatusOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectByVersionAndStatusOrderedByCreatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndStatusOrderedByUpdatedAtASC = `-- name: FetchProjectByVersionAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectByVersionAndStatusOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectByVersionAndStatusOrderedByUpdatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionAndStatusOrderedByUpdatedAtDESC = `-- name: FetchProjectByVersionAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectByVersionAndStatusOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectByVersionAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectByVersionAndStatusOrderedByUpdatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionOrderedByCreatedAtASC = `-- name: FetchProjectByVersionOrderedByCreatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectByVersionOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectByVersionOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectByVersionOrderedByCreatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionOrderedByCreatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionOrderedByCreatedAtDESC = `-- name: FetchProjectByVersionOrderedByCreatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectByVersionOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectByVersionOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectByVersionOrderedByCreatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionOrderedByCreatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionOrderedByUpdatedAtASC = `-- name: FetchProjectByVersionOrderedByUpdatedAtASC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectByVersionOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectByVersionOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectByVersionOrderedByUpdatedAtASCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionOrderedByUpdatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectByVersionOrderedByUpdatedAtDESC = `-- name: FetchProjectByVersionOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
     version = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectByVersionOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectByVersionOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectByVersionOrderedByUpdatedAtDESCParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectByVersionOrderedByUpdatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByReviewStatus = `-- name: FetchProjectVersionByReviewStatus :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     review_status = ?  
    LIMIT ?, ?
`

type FetchProjectVersionByReviewStatusParams struct {
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByReviewStatus(ctx context.Context, arg FetchProjectVersionByReviewStatusParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByReviewStatus, arg.ReviewStatus, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByReviewStatusAndStatus = `-- name: FetchProjectVersionByReviewStatusAndStatus :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     review_status = ? AND status = ?  
    LIMIT ?, ?
`

type FetchProjectVersionByReviewStatusAndStatusParams struct {
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByReviewStatusAndStatus(ctx context.Context, arg FetchProjectVersionByReviewStatusAndStatusParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByReviewStatusAndStatus,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByReviewStatusAndStatusOrderedByCreatedAtASC = `-- name: FetchProjectVersionByReviewStatusAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     review_status = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByReviewStatusAndStatusOrderedByCreatedAtASCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByReviewStatusAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectVersionByReviewStatusAndStatusOrderedByCreatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByReviewStatusAndStatusOrderedByCreatedAtASC,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByReviewStatusAndStatusOrderedByCreatedAtDESC = `-- name: FetchProjectVersionByReviewStatusAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     review_status = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByReviewStatusAndStatusOrderedByCreatedAtDESCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByReviewStatusAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectVersionByReviewStatusAndStatusOrderedByCreatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByReviewStatusAndStatusOrderedByCreatedAtDESC,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByReviewStatusAndStatusOrderedByUpdatedAtASC = `-- name: FetchProjectVersionByReviewStatusAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     review_status = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByReviewStatusAndStatusOrderedByUpdatedAtASCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByReviewStatusAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectVersionByReviewStatusAndStatusOrderedByUpdatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByReviewStatusAndStatusOrderedByUpdatedAtASC,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByReviewStatusAndStatusOrderedByUpdatedAtDESC = `-- name: FetchProjectVersionByReviewStatusAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     review_status = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByReviewStatusAndStatusOrderedByUpdatedAtDESCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByReviewStatusAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectVersionByReviewStatusAndStatusOrderedByUpdatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByReviewStatusAndStatusOrderedByUpdatedAtDESC,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByReviewStatusOrderedByCreatedAtASC = `-- name: FetchProjectVersionByReviewStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     review_status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByReviewStatusOrderedByCreatedAtASCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByReviewStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectVersionByReviewStatusOrderedByCreatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByReviewStatusOrderedByCreatedAtASC, arg.ReviewStatus, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByReviewStatusOrderedByCreatedAtDESC = `-- name: FetchProjectVersionByReviewStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     review_status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByReviewStatusOrderedByCreatedAtDESCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByReviewStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectVersionByReviewStatusOrderedByCreatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByReviewStatusOrderedByCreatedAtDESC, arg.ReviewStatus, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByReviewStatusOrderedByUpdatedAtASC = `-- name: FetchProjectVersionByReviewStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     review_status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByReviewStatusOrderedByUpdatedAtASCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByReviewStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectVersionByReviewStatusOrderedByUpdatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByReviewStatusOrderedByUpdatedAtASC, arg.ReviewStatus, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByReviewStatusOrderedByUpdatedAtDESC = `-- name: FetchProjectVersionByReviewStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     review_status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByReviewStatusOrderedByUpdatedAtDESCParams struct {
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByReviewStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectVersionByReviewStatusOrderedByUpdatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByReviewStatusOrderedByUpdatedAtDESC, arg.ReviewStatus, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByStatus = `-- name: FetchProjectVersionByStatus :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchProjectVersionByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByStatus(ctx context.Context, arg FetchProjectVersionByStatusParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByStatusOrderedByCreatedAtASC = `-- name: FetchProjectVersionByStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectVersionByStatusOrderedByCreatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByStatusOrderedByCreatedAtDESC = `-- name: FetchProjectVersionByStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectVersionByStatusOrderedByCreatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByStatusOrderedByUpdatedAtASC = `-- name: FetchProjectVersionByStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectVersionByStatusOrderedByUpdatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByStatusOrderedByUpdatedAtDESC = `-- name: FetchProjectVersionByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectVersionByStatusOrderedByUpdatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByUUID = `-- name: FetchProjectVersionByUUID :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     uuid = ?
`

func (q *Queries) FetchProjectVersionByUUID(ctx context.Context, uuid string) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByUUIDForUpdate = `-- name: FetchProjectVersionByUUIDForUpdate :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchProjectVersionByUUIDForUpdate(ctx context.Context, uuid string) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersion = `-- name: FetchProjectVersionByVersion :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ?  
    LIMIT ?, ?
`

type FetchProjectVersionByVersionParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersion(ctx context.Context, arg FetchProjectVersionByVersionParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersion, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndReviewStatus = `-- name: FetchProjectVersionByVersionAndReviewStatus :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND review_status = ?  
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndReviewStatusParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndReviewStatus(ctx context.Context, arg FetchProjectVersionByVersionAndReviewStatusParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndReviewStatus,
		arg.Version,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndReviewStatusAndStatus = `-- name: FetchProjectVersionByVersionAndReviewStatusAndStatus :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND review_status = ? AND status = ?  
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndReviewStatusAndStatusParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndReviewStatusAndStatus(ctx context.Context, arg FetchProjectVersionByVersionAndReviewStatusAndStatusParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndReviewStatusAndStatus,
		arg.Version,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByCreatedAtASC = `-- name: FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND review_status = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByCreatedAtASCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByCreatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByCreatedAtDESC = `-- name: FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND review_status = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByCreatedAtDESCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByCreatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByUpdatedAtASC = `-- name: FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND review_status = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByUpdatedAtASCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByUpdatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByUpdatedAtDESC = `-- name: FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND review_status = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByUpdatedAtDESCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Status       int64 `json:"status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByUpdatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndReviewStatusAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.ReviewStatus,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndReviewStatusOrderedByCreatedAtASC = `-- name: FetchProjectVersionByVersionAndReviewStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND review_status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndReviewStatusOrderedByCreatedAtASCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndReviewStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectVersionByVersionAndReviewStatusOrderedByCreatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndReviewStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndReviewStatusOrderedByCreatedAtDESC = `-- name: FetchProjectVersionByVersionAndReviewStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND review_status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndReviewStatusOrderedByCreatedAtDESCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndReviewStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectVersionByVersionAndReviewStatusOrderedByCreatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndReviewStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndReviewStatusOrderedByUpdatedAtASC = `-- name: FetchProjectVersionByVersionAndReviewStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND review_status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndReviewStatusOrderedByUpdatedAtASCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndReviewStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectVersionByVersionAndReviewStatusOrderedByUpdatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndReviewStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndReviewStatusOrderedByUpdatedAtDESC = `-- name: FetchProjectVersionByVersionAndReviewStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND review_status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndReviewStatusOrderedByUpdatedAtDESCParams struct {
	Version      int64 `json:"version"`
	ReviewStatus int64 `json:"review_status"`
	Offset       int32 `json:"offset"`
	Limit        int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndReviewStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectVersionByVersionAndReviewStatusOrderedByUpdatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndReviewStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.ReviewStatus,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndStatus = `-- name: FetchProjectVersionByVersionAndStatus :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND status = ?  
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndStatusParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndStatus(ctx context.Context, arg FetchProjectVersionByVersionAndStatusParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndStatus,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndStatusOrderedByCreatedAtASC = `-- name: FetchProjectVersionByVersionAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndStatusOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectVersionByVersionAndStatusOrderedByCreatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndStatusOrderedByCreatedAtDESC = `-- name: FetchProjectVersionByVersionAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndStatusOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectVersionByVersionAndStatusOrderedByCreatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndStatusOrderedByUpdatedAtASC = `-- name: FetchProjectVersionByVersionAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndStatusOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectVersionByVersionAndStatusOrderedByUpdatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionAndStatusOrderedByUpdatedAtDESC = `-- name: FetchProjectVersionByVersionAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionAndStatusOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectVersionByVersionAndStatusOrderedByUpdatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionOrderedByCreatedAtASC = `-- name: FetchProjectVersionByVersionOrderedByCreatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionOrderedByCreatedAtASC(ctx context.Context, arg FetchProjectVersionByVersionOrderedByCreatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionOrderedByCreatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionOrderedByCreatedAtDESC = `-- name: FetchProjectVersionByVersionOrderedByCreatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionOrderedByCreatedAtDESC(ctx context.Context, arg FetchProjectVersionByVersionOrderedByCreatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionOrderedByCreatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionOrderedByUpdatedAtASC = `-- name: FetchProjectVersionByVersionOrderedByUpdatedAtASC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionOrderedByUpdatedAtASC(ctx context.Context, arg FetchProjectVersionByVersionOrderedByUpdatedAtASCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionOrderedByUpdatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProjectVersionByVersionOrderedByUpdatedAtDESC = `-- name: FetchProjectVersionByVersionOrderedByUpdatedAtDESC :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
     version = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchProjectVersionByVersionOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchProjectVersionByVersionOrderedByUpdatedAtDESC(ctx context.Context, arg FetchProjectVersionByVersionOrderedByUpdatedAtDESCParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchProjectVersionByVersionOrderedByUpdatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByStatus = `-- name: FetchTeamByStatus :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchTeamByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchTeamByStatus(ctx context.Context, arg FetchTeamByStatusParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByStatusOrderedByCreatedAtASC = `-- name: FetchTeamByStatusOrderedByCreatedAtASC :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchTeamByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchTeamByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchTeamByStatusOrderedByCreatedAtASCParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByStatusOrderedByCreatedAtDESC = `-- name: FetchTeamByStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchTeamByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchTeamByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchTeamByStatusOrderedByCreatedAtDESCParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByStatusOrderedByUpdatedAtASC = `-- name: FetchTeamByStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchTeamByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchTeamByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchTeamByStatusOrderedByUpdatedAtASCParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByStatusOrderedByUpdatedAtDESC = `-- name: FetchTeamByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchTeamByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchTeamByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchTeamByStatusOrderedByUpdatedAtDESCParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByUUID = `-- name: FetchTeamByUUID :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     uuid = ?
`

func (q *Queries) FetchTeamByUUID(ctx context.Context, uuid string) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByUUIDForUpdate = `-- name: FetchTeamByUUIDForUpdate :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchTeamByUUIDForUpdate(ctx context.Context, uuid string) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByVersion = `-- name: FetchTeamByVersion :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     version = ?  
    LIMIT ?, ?
`

type FetchTeamByVersionParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchTeamByVersion(ctx context.Context, arg FetchTeamByVersionParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByVersion, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByVersionAndStatus = `-- name: FetchTeamByVersionAndStatus :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     version = ? AND status = ?  
    LIMIT ?, ?
`

type FetchTeamByVersionAndStatusParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchTeamByVersionAndStatus(ctx context.Context, arg FetchTeamByVersionAndStatusParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByVersionAndStatus,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByVersionAndStatusOrderedByCreatedAtASC = `-- name: FetchTeamByVersionAndStatusOrderedByCreatedAtASC :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchTeamByVersionAndStatusOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchTeamByVersionAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchTeamByVersionAndStatusOrderedByCreatedAtASCParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByVersionAndStatusOrderedByCreatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByVersionAndStatusOrderedByCreatedAtDESC = `-- name: FetchTeamByVersionAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     version = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchTeamByVersionAndStatusOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchTeamByVersionAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchTeamByVersionAndStatusOrderedByCreatedAtDESCParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByVersionAndStatusOrderedByCreatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByVersionAndStatusOrderedByUpdatedAtASC = `-- name: FetchTeamByVersionAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchTeamByVersionAndStatusOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchTeamByVersionAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchTeamByVersionAndStatusOrderedByUpdatedAtASCParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByVersionAndStatusOrderedByUpdatedAtASC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByVersionAndStatusOrderedByUpdatedAtDESC = `-- name: FetchTeamByVersionAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     version = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchTeamByVersionAndStatusOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Status  int64 `json:"status"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchTeamByVersionAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchTeamByVersionAndStatusOrderedByUpdatedAtDESCParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByVersionAndStatusOrderedByUpdatedAtDESC,
		arg.Version,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByVersionOrderedByCreatedAtASC = `-- name: FetchTeamByVersionOrderedByCreatedAtASC :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     version = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchTeamByVersionOrderedByCreatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchTeamByVersionOrderedByCreatedAtASC(ctx context.Context, arg FetchTeamByVersionOrderedByCreatedAtASCParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByVersionOrderedByCreatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByVersionOrderedByCreatedAtDESC = `-- name: FetchTeamByVersionOrderedByCreatedAtDESC :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     version = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchTeamByVersionOrderedByCreatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchTeamByVersionOrderedByCreatedAtDESC(ctx context.Context, arg FetchTeamByVersionOrderedByCreatedAtDESCParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByVersionOrderedByCreatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByVersionOrderedByUpdatedAtASC = `-- name: FetchTeamByVersionOrderedByUpdatedAtASC :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     version = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchTeamByVersionOrderedByUpdatedAtASCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchTeamByVersionOrderedByUpdatedAtASC(ctx context.Context, arg FetchTeamByVersionOrderedByUpdatedAtASCParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByVersionOrderedByUpdatedAtASC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchTeamByVersionOrderedByUpdatedAtDESC = `-- name: FetchTeamByVersionOrderedByUpdatedAtDESC :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
     version = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchTeamByVersionOrderedByUpdatedAtDESCParams struct {
	Version int64 `json:"version"`
	Offset  int32 `json:"offset"`
	Limit   int32 `json:"limit"`
}

func (q *Queries) FetchTeamByVersionOrderedByUpdatedAtDESC(ctx context.Context, arg FetchTeamByVersionOrderedByUpdatedAtDESCParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, fetchTeamByVersionOrderedByUpdatedAtDESC, arg.Version, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmail = `-- name: FetchUserByEmail :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     email = ?  
    LIMIT ?, ?
`

type FetchUserByEmailParams struct {
	Email  string `json:"email"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmail(ctx context.Context, arg FetchUserByEmailParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmail, arg.Email, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailAndStatus = `-- name: FetchUserByEmailAndStatus :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     email = ? AND status = ?  
    LIMIT ?, ?
`

type FetchUserByEmailAndStatusParams struct {
	Email  string `json:"email"`
	Status int64  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailAndStatus(ctx context.Context, arg FetchUserByEmailAndStatusParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailAndStatus,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailAndStatusOrderedByCreatedAtASC = `-- name: FetchUserByEmailAndStatusOrderedByCreatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     email = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserByEmailAndStatusOrderedByCreatedAtASCParams struct {
	Email  string `json:"email"`
	Status int64  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserByEmailAndStatusOrderedByCreatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailAndStatusOrderedByCreatedAtASC,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailAndStatusOrderedByCreatedAtDESC = `-- name: FetchUserByEmailAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     email = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserByEmailAndStatusOrderedByCreatedAtDESCParams struct {
	Email  string `json:"email"`
	Status int64  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserByEmailAndStatusOrderedByCreatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailAndStatusOrderedByCreatedAtDESC,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailAndStatusOrderedByUpdatedAtASC = `-- name: FetchUserByEmailAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     email = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserByEmailAndStatusOrderedByUpdatedAtASCParams struct {
	Email  string `json:"email"`
	Status int64  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserByEmailAndStatusOrderedByUpdatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailAndStatusOrderedByUpdatedAtASC,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailAndStatusOrderedByUpdatedAtDESC = `-- name: FetchUserByEmailAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     email = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserByEmailAndStatusOrderedByUpdatedAtDESCParams struct {
	Email  string `json:"email"`
	Status int64  `json:"status"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserByEmailAndStatusOrderedByUpdatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailAndStatusOrderedByUpdatedAtDESC,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailOrderedByCreatedAtASC = `-- name: FetchUserByEmailOrderedByCreatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     email = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserByEmailOrderedByCreatedAtASCParams struct {
	Email  string `json:"email"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailOrderedByCreatedAtASC(ctx context.Context, arg FetchUserByEmailOrderedByCreatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailOrderedByCreatedAtASC, arg.Email, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailOrderedByCreatedAtDESC = `-- name: FetchUserByEmailOrderedByCreatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     email = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserByEmailOrderedByCreatedAtDESCParams struct {
	Email  string `json:"email"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserByEmailOrderedByCreatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailOrderedByCreatedAtDESC, arg.Email, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailOrderedByUpdatedAtASC = `-- name: FetchUserByEmailOrderedByUpdatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     email = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserByEmailOrderedByUpdatedAtASCParams struct {
	Email  string `json:"email"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserByEmailOrderedByUpdatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailOrderedByUpdatedAtASC, arg.Email, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByEmailOrderedByUpdatedAtDESC = `-- name: FetchUserByEmailOrderedByUpdatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     email = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserByEmailOrderedByUpdatedAtDESCParams struct {
	Email  string `json:"email"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) FetchUserByEmailOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserByEmailOrderedByUpdatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByEmailOrderedByUpdatedAtDESC, arg.Email, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifier = `-- name: FetchUserByIdentifier :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ?  
    LIMIT ?, ?
`

type FetchUserByIdentifierParams struct {
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifier(ctx context.Context, arg FetchUserByIdentifierParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifier, arg.Identifier, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndEmail = `-- name: FetchUserByIdentifierAndEmail :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND email = ?  
    LIMIT ?, ?
`

type FetchUserByIdentifierAndEmailParams struct {
	Identifier string `json:"identifier"`
	Email      string `json:"email"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndEmail(ctx context.Context, arg FetchUserByIdentifierAndEmailParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndEmail,
		arg.Identifier,
		arg.Email,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndEmailAndStatus = `-- name: FetchUserByIdentifierAndEmailAndStatus :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND email = ? AND status = ?  
    LIMIT ?, ?
`

type FetchUserByIdentifierAndEmailAndStatusParams struct {
	Identifier string `json:"identifier"`
	Email      string `json:"email"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndEmailAndStatus(ctx context.Context, arg FetchUserByIdentifierAndEmailAndStatusParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndEmailAndStatus,
		arg.Identifier,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndEmailAndStatusOrderedByCreatedAtASC = `-- name: FetchUserByIdentifierAndEmailAndStatusOrderedByCreatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND email = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserByIdentifierAndEmailAndStatusOrderedByCreatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Email      string `json:"email"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndEmailAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserByIdentifierAndEmailAndStatusOrderedByCreatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndEmailAndStatusOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndEmailAndStatusOrderedByCreatedAtDESC = `-- name: FetchUserByIdentifierAndEmailAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND email = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserByIdentifierAndEmailAndStatusOrderedByCreatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Email      string `json:"email"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndEmailAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserByIdentifierAndEmailAndStatusOrderedByCreatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndEmailAndStatusOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndEmailAndStatusOrderedByUpdatedAtASC = `-- name: FetchUserByIdentifierAndEmailAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND email = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserByIdentifierAndEmailAndStatusOrderedByUpdatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Email      string `json:"email"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndEmailAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserByIdentifierAndEmailAndStatusOrderedByUpdatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndEmailAndStatusOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndEmailAndStatusOrderedByUpdatedAtDESC = `-- name: FetchUserByIdentifierAndEmailAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND email = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserByIdentifierAndEmailAndStatusOrderedByUpdatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Email      string `json:"email"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndEmailAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserByIdentifierAndEmailAndStatusOrderedByUpdatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndEmailAndStatusOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Email,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndEmailOrderedByCreatedAtASC = `-- name: FetchUserByIdentifierAndEmailOrderedByCreatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND email = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserByIdentifierAndEmailOrderedByCreatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Email      string `json:"email"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndEmailOrderedByCreatedAtASC(ctx context.Context, arg FetchUserByIdentifierAndEmailOrderedByCreatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndEmailOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Email,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndEmailOrderedByCreatedAtDESC = `-- name: FetchUserByIdentifierAndEmailOrderedByCreatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND email = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserByIdentifierAndEmailOrderedByCreatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Email      string `json:"email"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndEmailOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserByIdentifierAndEmailOrderedByCreatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndEmailOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Email,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndEmailOrderedByUpdatedAtASC = `-- name: FetchUserByIdentifierAndEmailOrderedByUpdatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND email = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserByIdentifierAndEmailOrderedByUpdatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Email      string `json:"email"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndEmailOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserByIdentifierAndEmailOrderedByUpdatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndEmailOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Email,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndEmailOrderedByUpdatedAtDESC = `-- name: FetchUserByIdentifierAndEmailOrderedByUpdatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND email = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserByIdentifierAndEmailOrderedByUpdatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Email      string `json:"email"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndEmailOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserByIdentifierAndEmailOrderedByUpdatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndEmailOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Email,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndStatus = `-- name: FetchUserByIdentifierAndStatus :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND status = ?  
    LIMIT ?, ?
`

type FetchUserByIdentifierAndStatusParams struct {
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndStatus(ctx context.Context, arg FetchUserByIdentifierAndStatusParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndStatus,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndStatusOrderedByCreatedAtASC = `-- name: FetchUserByIdentifierAndStatusOrderedByCreatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserByIdentifierAndStatusOrderedByCreatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserByIdentifierAndStatusOrderedByCreatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndStatusOrderedByCreatedAtASC,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndStatusOrderedByCreatedAtDESC = `-- name: FetchUserByIdentifierAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserByIdentifierAndStatusOrderedByCreatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserByIdentifierAndStatusOrderedByCreatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndStatusOrderedByCreatedAtDESC,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndStatusOrderedByUpdatedAtASC = `-- name: FetchUserByIdentifierAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserByIdentifierAndStatusOrderedByUpdatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserByIdentifierAndStatusOrderedByUpdatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndStatusOrderedByUpdatedAtASC,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierAndStatusOrderedByUpdatedAtDESC = `-- name: FetchUserByIdentifierAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserByIdentifierAndStatusOrderedByUpdatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Status     int64  `json:"status"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserByIdentifierAndStatusOrderedByUpdatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierAndStatusOrderedByUpdatedAtDESC,
		arg.Identifier,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierOrderedByCreatedAtASC = `-- name: FetchUserByIdentifierOrderedByCreatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserByIdentifierOrderedByCreatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierOrderedByCreatedAtASC(ctx context.Context, arg FetchUserByIdentifierOrderedByCreatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierOrderedByCreatedAtASC, arg.Identifier, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierOrderedByCreatedAtDESC = `-- name: FetchUserByIdentifierOrderedByCreatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserByIdentifierOrderedByCreatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserByIdentifierOrderedByCreatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierOrderedByCreatedAtDESC, arg.Identifier, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierOrderedByUpdatedAtASC = `-- name: FetchUserByIdentifierOrderedByUpdatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserByIdentifierOrderedByUpdatedAtASCParams struct {
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserByIdentifierOrderedByUpdatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierOrderedByUpdatedAtASC, arg.Identifier, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByIdentifierOrderedByUpdatedAtDESC = `-- name: FetchUserByIdentifierOrderedByUpdatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     identifier = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserByIdentifierOrderedByUpdatedAtDESCParams struct {
	Identifier string `json:"identifier"`
	Offset     int32  `json:"offset"`
	Limit      int32  `json:"limit"`
}

func (q *Queries) FetchUserByIdentifierOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserByIdentifierOrderedByUpdatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByIdentifierOrderedByUpdatedAtDESC, arg.Identifier, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByStatus = `-- name: FetchUserByStatus :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchUserByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserByStatus(ctx context.Context, arg FetchUserByStatusParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByStatusOrderedByCreatedAtASC = `-- name: FetchUserByStatusOrderedByCreatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserByStatusOrderedByCreatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByStatusOrderedByCreatedAtDESC = `-- name: FetchUserByStatusOrderedByCreatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserByStatusOrderedByCreatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByStatusOrderedByUpdatedAtASC = `-- name: FetchUserByStatusOrderedByUpdatedAtASC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserByStatusOrderedByUpdatedAtASCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByStatusOrderedByUpdatedAtDESC = `-- name: FetchUserByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserByStatusOrderedByUpdatedAtDESCParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByUUID = `-- name: FetchUserByUUID :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     uuid = ?
`

func (q *Queries) FetchUserByUUID(ctx context.Context, uuid string) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserByUUIDForUpdate = `-- name: FetchUserByUUIDForUpdate :many
SELECT uuid, identifier, name, last_name, email, user_type, country_ios2, locale, metadata, status, created_at, updated_at FROM user
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchUserByUUIDForUpdate(ctx context.Context, uuid string) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.UUID,
			&i.Identifier,
			&i.Name,
			&i.LastName,
			&i.Email,
			&i.UserType,
			&i.CountryIos2,
			&i.Locale,
			&i.Metadata,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserConnectionByStatus = `-- name: FetchUserConnectionByStatus :many
SELECT uuid, user_uuid, project_uuid, project_version_uuid, type, type_config, db_schema, executions, status, created_at, updated_at FROM user_connection
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchUserConnectionByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserConnectionByStatus(ctx context.Context, arg FetchUserConnectionByStatusParams) ([]UserConnection, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserConnectionByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserConnection
	for rows.Next() {
		var i UserConnection
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.Type,
			&i.TypeConfig,
			&i.DbSchema,
			&i.Executions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserConnectionByStatusOrderedByCreatedAtASC = `-- name: FetchUserConnectionByStatusOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, project_uuid, project_version_uuid, type, type_config, db_schema, executions, status, created_at, updated_at FROM user_connection
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserConnectionByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserConnectionByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserConnectionByStatusOrderedByCreatedAtASCParams) ([]UserConnection, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserConnectionByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserConnection
	for rows.Next() {
		var i UserConnection
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.Type,
			&i.TypeConfig,
			&i.DbSchema,
			&i.Executions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserConnectionByStatusOrderedByCreatedAtDESC = `-- name: FetchUserConnectionByStatusOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, project_uuid, project_version_uuid, type, type_config, db_schema, executions, status, created_at, updated_at FROM user_connection
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserConnectionByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserConnectionByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserConnectionByStatusOrderedByCreatedAtDESCParams) ([]UserConnection, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserConnectionByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserConnection
	for rows.Next() {
		var i UserConnection
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.Type,
			&i.TypeConfig,
			&i.DbSchema,
			&i.Executions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserConnectionByStatusOrderedByUpdatedAtASC = `-- name: FetchUserConnectionByStatusOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, project_uuid, project_version_uuid, type, type_config, db_schema, executions, status, created_at, updated_at FROM user_connection
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserConnectionByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserConnectionByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserConnectionByStatusOrderedByUpdatedAtASCParams) ([]UserConnection, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserConnectionByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserConnection
	for rows.Next() {
		var i UserConnection
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.Type,
			&i.TypeConfig,
			&i.DbSchema,
			&i.Executions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserConnectionByStatusOrderedByUpdatedAtDESC = `-- name: FetchUserConnectionByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, project_uuid, project_version_uuid, type, type_config, db_schema, executions, status, created_at, updated_at FROM user_connection
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserConnectionByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserConnectionByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserConnectionByStatusOrderedByUpdatedAtDESCParams) ([]UserConnection, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserConnectionByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserConnection
	for rows.Next() {
		var i UserConnection
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.Type,
			&i.TypeConfig,
			&i.DbSchema,
			&i.Executions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserConnectionByUUID = `-- name: FetchUserConnectionByUUID :many
SELECT uuid, user_uuid, project_uuid, project_version_uuid, type, type_config, db_schema, executions, status, created_at, updated_at FROM user_connection
WHERE 
     uuid = ?
`

func (q *Queries) FetchUserConnectionByUUID(ctx context.Context, uuid string) ([]UserConnection, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserConnectionByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserConnection
	for rows.Next() {
		var i UserConnection
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.Type,
			&i.TypeConfig,
			&i.DbSchema,
			&i.Executions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserConnectionByUUIDForUpdate = `-- name: FetchUserConnectionByUUIDForUpdate :many
SELECT uuid, user_uuid, project_uuid, project_version_uuid, type, type_config, db_schema, executions, status, created_at, updated_at FROM user_connection
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchUserConnectionByUUIDForUpdate(ctx context.Context, uuid string) ([]UserConnection, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserConnectionByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserConnection
	for rows.Next() {
		var i UserConnection
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.Type,
			&i.TypeConfig,
			&i.DbSchema,
			&i.Executions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByRole = `-- name: FetchUserProjectByRole :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     role = ?  
    LIMIT ?, ?
`

type FetchUserProjectByRoleParams struct {
	Role   int64 `json:"role"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByRole(ctx context.Context, arg FetchUserProjectByRoleParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByRole, arg.Role, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByRoleAndStatus = `-- name: FetchUserProjectByRoleAndStatus :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     role = ? AND status = ?  
    LIMIT ?, ?
`

type FetchUserProjectByRoleAndStatusParams struct {
	Role   int64 `json:"role"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByRoleAndStatus(ctx context.Context, arg FetchUserProjectByRoleAndStatusParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByRoleAndStatus,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByRoleAndStatusOrderedByCreatedAtASC = `-- name: FetchUserProjectByRoleAndStatusOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     role = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByRoleAndStatusOrderedByCreatedAtASCParams struct {
	Role   int64 `json:"role"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByRoleAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserProjectByRoleAndStatusOrderedByCreatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByRoleAndStatusOrderedByCreatedAtASC,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByRoleAndStatusOrderedByCreatedAtDESC = `-- name: FetchUserProjectByRoleAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     role = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByRoleAndStatusOrderedByCreatedAtDESCParams struct {
	Role   int64 `json:"role"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByRoleAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserProjectByRoleAndStatusOrderedByCreatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByRoleAndStatusOrderedByCreatedAtDESC,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByRoleAndStatusOrderedByUpdatedAtASC = `-- name: FetchUserProjectByRoleAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     role = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByRoleAndStatusOrderedByUpdatedAtASCParams struct {
	Role   int64 `json:"role"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByRoleAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserProjectByRoleAndStatusOrderedByUpdatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByRoleAndStatusOrderedByUpdatedAtASC,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByRoleAndStatusOrderedByUpdatedAtDESC = `-- name: FetchUserProjectByRoleAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     role = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByRoleAndStatusOrderedByUpdatedAtDESCParams struct {
	Role   int64 `json:"role"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByRoleAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserProjectByRoleAndStatusOrderedByUpdatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByRoleAndStatusOrderedByUpdatedAtDESC,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByRoleOrderedByCreatedAtASC = `-- name: FetchUserProjectByRoleOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     role = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByRoleOrderedByCreatedAtASCParams struct {
	Role   int64 `json:"role"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByRoleOrderedByCreatedAtASC(ctx context.Context, arg FetchUserProjectByRoleOrderedByCreatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByRoleOrderedByCreatedAtASC, arg.Role, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByRoleOrderedByCreatedAtDESC = `-- name: FetchUserProjectByRoleOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     role = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByRoleOrderedByCreatedAtDESCParams struct {
	Role   int64 `json:"role"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByRoleOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserProjectByRoleOrderedByCreatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByRoleOrderedByCreatedAtDESC, arg.Role, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByRoleOrderedByUpdatedAtASC = `-- name: FetchUserProjectByRoleOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     role = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByRoleOrderedByUpdatedAtASCParams struct {
	Role   int64 `json:"role"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByRoleOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserProjectByRoleOrderedByUpdatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByRoleOrderedByUpdatedAtASC, arg.Role, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByRoleOrderedByUpdatedAtDESC = `-- name: FetchUserProjectByRoleOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     role = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByRoleOrderedByUpdatedAtDESCParams struct {
	Role   int64 `json:"role"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByRoleOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserProjectByRoleOrderedByUpdatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByRoleOrderedByUpdatedAtDESC, arg.Role, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByStatus = `-- name: FetchUserProjectByStatus :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchUserProjectByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByStatus(ctx context.Context, arg FetchUserProjectByStatusParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByStatusOrderedByCreatedAtASC = `-- name: FetchUserProjectByStatusOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserProjectByStatusOrderedByCreatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByStatusOrderedByCreatedAtDESC = `-- name: FetchUserProjectByStatusOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserProjectByStatusOrderedByCreatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByStatusOrderedByUpdatedAtASC = `-- name: FetchUserProjectByStatusOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserProjectByStatusOrderedByUpdatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByStatusOrderedByUpdatedAtDESC = `-- name: FetchUserProjectByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserProjectByStatusOrderedByUpdatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUUID = `-- name: FetchUserProjectByUUID :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     uuid = ?
`

func (q *Queries) FetchUserProjectByUUID(ctx context.Context, uuid string) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUUIDForUpdate = `-- name: FetchUserProjectByUUIDForUpdate :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchUserProjectByUUIDForUpdate(ctx context.Context, uuid string) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmail = `-- name: FetchUserProjectByUserEmail :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ?  
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmail(ctx context.Context, arg FetchUserProjectByUserEmailParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmail, arg.UserEmail, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndRole = `-- name: FetchUserProjectByUserEmailAndRole :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND role = ?  
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndRoleParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndRole(ctx context.Context, arg FetchUserProjectByUserEmailAndRoleParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndRole,
		arg.UserEmail,
		arg.Role,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndRoleAndStatus = `-- name: FetchUserProjectByUserEmailAndRoleAndStatus :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND role = ? AND status = ?  
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndRoleAndStatusParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndRoleAndStatus(ctx context.Context, arg FetchUserProjectByUserEmailAndRoleAndStatusParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndRoleAndStatus,
		arg.UserEmail,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndRoleAndStatusOrderedByCreatedAtASC = `-- name: FetchUserProjectByUserEmailAndRoleAndStatusOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND role = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndRoleAndStatusOrderedByCreatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndRoleAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserProjectByUserEmailAndRoleAndStatusOrderedByCreatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndRoleAndStatusOrderedByCreatedAtASC,
		arg.UserEmail,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndRoleAndStatusOrderedByCreatedAtDESC = `-- name: FetchUserProjectByUserEmailAndRoleAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND role = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndRoleAndStatusOrderedByCreatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndRoleAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserProjectByUserEmailAndRoleAndStatusOrderedByCreatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndRoleAndStatusOrderedByCreatedAtDESC,
		arg.UserEmail,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndRoleAndStatusOrderedByUpdatedAtASC = `-- name: FetchUserProjectByUserEmailAndRoleAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND role = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndRoleAndStatusOrderedByUpdatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndRoleAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserProjectByUserEmailAndRoleAndStatusOrderedByUpdatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndRoleAndStatusOrderedByUpdatedAtASC,
		arg.UserEmail,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndRoleAndStatusOrderedByUpdatedAtDESC = `-- name: FetchUserProjectByUserEmailAndRoleAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND role = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndRoleAndStatusOrderedByUpdatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndRoleAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserProjectByUserEmailAndRoleAndStatusOrderedByUpdatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndRoleAndStatusOrderedByUpdatedAtDESC,
		arg.UserEmail,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndRoleOrderedByCreatedAtASC = `-- name: FetchUserProjectByUserEmailAndRoleOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND role = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndRoleOrderedByCreatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndRoleOrderedByCreatedAtASC(ctx context.Context, arg FetchUserProjectByUserEmailAndRoleOrderedByCreatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndRoleOrderedByCreatedAtASC,
		arg.UserEmail,
		arg.Role,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndRoleOrderedByCreatedAtDESC = `-- name: FetchUserProjectByUserEmailAndRoleOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND role = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndRoleOrderedByCreatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndRoleOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserProjectByUserEmailAndRoleOrderedByCreatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndRoleOrderedByCreatedAtDESC,
		arg.UserEmail,
		arg.Role,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndRoleOrderedByUpdatedAtASC = `-- name: FetchUserProjectByUserEmailAndRoleOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND role = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndRoleOrderedByUpdatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndRoleOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserProjectByUserEmailAndRoleOrderedByUpdatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndRoleOrderedByUpdatedAtASC,
		arg.UserEmail,
		arg.Role,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndRoleOrderedByUpdatedAtDESC = `-- name: FetchUserProjectByUserEmailAndRoleOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND role = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndRoleOrderedByUpdatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndRoleOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserProjectByUserEmailAndRoleOrderedByUpdatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndRoleOrderedByUpdatedAtDESC,
		arg.UserEmail,
		arg.Role,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndStatus = `-- name: FetchUserProjectByUserEmailAndStatus :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND status = ?  
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndStatusParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndStatus(ctx context.Context, arg FetchUserProjectByUserEmailAndStatusParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndStatus,
		arg.UserEmail,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndStatusOrderedByCreatedAtASC = `-- name: FetchUserProjectByUserEmailAndStatusOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndStatusOrderedByCreatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserProjectByUserEmailAndStatusOrderedByCreatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndStatusOrderedByCreatedAtASC,
		arg.UserEmail,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndStatusOrderedByCreatedAtDESC = `-- name: FetchUserProjectByUserEmailAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndStatusOrderedByCreatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserProjectByUserEmailAndStatusOrderedByCreatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndStatusOrderedByCreatedAtDESC,
		arg.UserEmail,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndStatusOrderedByUpdatedAtASC = `-- name: FetchUserProjectByUserEmailAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndStatusOrderedByUpdatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserProjectByUserEmailAndStatusOrderedByUpdatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndStatusOrderedByUpdatedAtASC,
		arg.UserEmail,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailAndStatusOrderedByUpdatedAtDESC = `-- name: FetchUserProjectByUserEmailAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailAndStatusOrderedByUpdatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserProjectByUserEmailAndStatusOrderedByUpdatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailAndStatusOrderedByUpdatedAtDESC,
		arg.UserEmail,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailOrderedByCreatedAtASC = `-- name: FetchUserProjectByUserEmailOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailOrderedByCreatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailOrderedByCreatedAtASC(ctx context.Context, arg FetchUserProjectByUserEmailOrderedByCreatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailOrderedByCreatedAtASC, arg.UserEmail, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailOrderedByCreatedAtDESC = `-- name: FetchUserProjectByUserEmailOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailOrderedByCreatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserProjectByUserEmailOrderedByCreatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailOrderedByCreatedAtDESC, arg.UserEmail, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailOrderedByUpdatedAtASC = `-- name: FetchUserProjectByUserEmailOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailOrderedByUpdatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserProjectByUserEmailOrderedByUpdatedAtASCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailOrderedByUpdatedAtASC, arg.UserEmail, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectByUserEmailOrderedByUpdatedAtDESC = `-- name: FetchUserProjectByUserEmailOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, project_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project
WHERE 
     user_email = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserProjectByUserEmailOrderedByUpdatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserProjectByUserEmailOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserProjectByUserEmailOrderedByUpdatedAtDESCParams) ([]UserProject, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectByUserEmailOrderedByUpdatedAtDESC, arg.UserEmail, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProject
	for rows.Next() {
		var i UserProject
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.ProjectUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectVersionByStatus = `-- name: FetchUserProjectVersionByStatus :many
SELECT uuid, version, project_version_uuid, user_uuid, data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project_version
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchUserProjectVersionByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectVersionByStatus(ctx context.Context, arg FetchUserProjectVersionByStatusParams) ([]UserProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectVersionByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProjectVersion
	for rows.Next() {
		var i UserProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ProjectVersionUUID,
			&i.UserUUID,
			&i.Data,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectVersionByStatusOrderedByCreatedAtASC = `-- name: FetchUserProjectVersionByStatusOrderedByCreatedAtASC :many
SELECT uuid, version, project_version_uuid, user_uuid, data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project_version
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserProjectVersionByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectVersionByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserProjectVersionByStatusOrderedByCreatedAtASCParams) ([]UserProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectVersionByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProjectVersion
	for rows.Next() {
		var i UserProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ProjectVersionUUID,
			&i.UserUUID,
			&i.Data,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectVersionByStatusOrderedByCreatedAtDESC = `-- name: FetchUserProjectVersionByStatusOrderedByCreatedAtDESC :many
SELECT uuid, version, project_version_uuid, user_uuid, data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project_version
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserProjectVersionByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectVersionByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserProjectVersionByStatusOrderedByCreatedAtDESCParams) ([]UserProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectVersionByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProjectVersion
	for rows.Next() {
		var i UserProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ProjectVersionUUID,
			&i.UserUUID,
			&i.Data,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectVersionByStatusOrderedByUpdatedAtASC = `-- name: FetchUserProjectVersionByStatusOrderedByUpdatedAtASC :many
SELECT uuid, version, project_version_uuid, user_uuid, data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project_version
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserProjectVersionByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectVersionByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserProjectVersionByStatusOrderedByUpdatedAtASCParams) ([]UserProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectVersionByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProjectVersion
	for rows.Next() {
		var i UserProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ProjectVersionUUID,
			&i.UserUUID,
			&i.Data,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectVersionByStatusOrderedByUpdatedAtDESC = `-- name: FetchUserProjectVersionByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, version, project_version_uuid, user_uuid, data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project_version
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserProjectVersionByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserProjectVersionByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserProjectVersionByStatusOrderedByUpdatedAtDESCParams) ([]UserProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectVersionByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProjectVersion
	for rows.Next() {
		var i UserProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ProjectVersionUUID,
			&i.UserUUID,
			&i.Data,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectVersionByUUID = `-- name: FetchUserProjectVersionByUUID :many
SELECT uuid, version, project_version_uuid, user_uuid, data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project_version
WHERE 
     uuid = ?
`

func (q *Queries) FetchUserProjectVersionByUUID(ctx context.Context, uuid string) ([]UserProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectVersionByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProjectVersion
	for rows.Next() {
		var i UserProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ProjectVersionUUID,
			&i.UserUUID,
			&i.Data,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserProjectVersionByUUIDForUpdate = `-- name: FetchUserProjectVersionByUUIDForUpdate :many
SELECT uuid, version, project_version_uuid, user_uuid, data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_project_version
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchUserProjectVersionByUUIDForUpdate(ctx context.Context, uuid string) ([]UserProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserProjectVersionByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserProjectVersion
	for rows.Next() {
		var i UserProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.ProjectVersionUUID,
			&i.UserUUID,
			&i.Data,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByRole = `-- name: FetchUserTeamByRole :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     role = ?  
    LIMIT ?, ?
`

type FetchUserTeamByRoleParams struct {
	Role   int64 `json:"role"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByRole(ctx context.Context, arg FetchUserTeamByRoleParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByRole, arg.Role, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByRoleAndStatus = `-- name: FetchUserTeamByRoleAndStatus :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     role = ? AND status = ?  
    LIMIT ?, ?
`

type FetchUserTeamByRoleAndStatusParams struct {
	Role   int64 `json:"role"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByRoleAndStatus(ctx context.Context, arg FetchUserTeamByRoleAndStatusParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByRoleAndStatus,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByRoleAndStatusOrderedByCreatedAtASC = `-- name: FetchUserTeamByRoleAndStatusOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     role = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByRoleAndStatusOrderedByCreatedAtASCParams struct {
	Role   int64 `json:"role"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByRoleAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserTeamByRoleAndStatusOrderedByCreatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByRoleAndStatusOrderedByCreatedAtASC,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByRoleAndStatusOrderedByCreatedAtDESC = `-- name: FetchUserTeamByRoleAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     role = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByRoleAndStatusOrderedByCreatedAtDESCParams struct {
	Role   int64 `json:"role"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByRoleAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserTeamByRoleAndStatusOrderedByCreatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByRoleAndStatusOrderedByCreatedAtDESC,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByRoleAndStatusOrderedByUpdatedAtASC = `-- name: FetchUserTeamByRoleAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     role = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByRoleAndStatusOrderedByUpdatedAtASCParams struct {
	Role   int64 `json:"role"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByRoleAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserTeamByRoleAndStatusOrderedByUpdatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByRoleAndStatusOrderedByUpdatedAtASC,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByRoleAndStatusOrderedByUpdatedAtDESC = `-- name: FetchUserTeamByRoleAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     role = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByRoleAndStatusOrderedByUpdatedAtDESCParams struct {
	Role   int64 `json:"role"`
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByRoleAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserTeamByRoleAndStatusOrderedByUpdatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByRoleAndStatusOrderedByUpdatedAtDESC,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByRoleOrderedByCreatedAtASC = `-- name: FetchUserTeamByRoleOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     role = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByRoleOrderedByCreatedAtASCParams struct {
	Role   int64 `json:"role"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByRoleOrderedByCreatedAtASC(ctx context.Context, arg FetchUserTeamByRoleOrderedByCreatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByRoleOrderedByCreatedAtASC, arg.Role, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByRoleOrderedByCreatedAtDESC = `-- name: FetchUserTeamByRoleOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     role = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByRoleOrderedByCreatedAtDESCParams struct {
	Role   int64 `json:"role"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByRoleOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserTeamByRoleOrderedByCreatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByRoleOrderedByCreatedAtDESC, arg.Role, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByRoleOrderedByUpdatedAtASC = `-- name: FetchUserTeamByRoleOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     role = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByRoleOrderedByUpdatedAtASCParams struct {
	Role   int64 `json:"role"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByRoleOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserTeamByRoleOrderedByUpdatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByRoleOrderedByUpdatedAtASC, arg.Role, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByRoleOrderedByUpdatedAtDESC = `-- name: FetchUserTeamByRoleOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     role = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByRoleOrderedByUpdatedAtDESCParams struct {
	Role   int64 `json:"role"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByRoleOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserTeamByRoleOrderedByUpdatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByRoleOrderedByUpdatedAtDESC, arg.Role, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByStatus = `-- name: FetchUserTeamByStatus :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     status = ?  
    LIMIT ?, ?
`

type FetchUserTeamByStatusParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByStatus(ctx context.Context, arg FetchUserTeamByStatusParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByStatus, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByStatusOrderedByCreatedAtASC = `-- name: FetchUserTeamByStatusOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByStatusOrderedByCreatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserTeamByStatusOrderedByCreatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByStatusOrderedByCreatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByStatusOrderedByCreatedAtDESC = `-- name: FetchUserTeamByStatusOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByStatusOrderedByCreatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserTeamByStatusOrderedByCreatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByStatusOrderedByCreatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByStatusOrderedByUpdatedAtASC = `-- name: FetchUserTeamByStatusOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByStatusOrderedByUpdatedAtASCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserTeamByStatusOrderedByUpdatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByStatusOrderedByUpdatedAtASC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByStatusOrderedByUpdatedAtDESC = `-- name: FetchUserTeamByStatusOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByStatusOrderedByUpdatedAtDESCParams struct {
	Status int64 `json:"status"`
	Offset int32 `json:"offset"`
	Limit  int32 `json:"limit"`
}

func (q *Queries) FetchUserTeamByStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserTeamByStatusOrderedByUpdatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByStatusOrderedByUpdatedAtDESC, arg.Status, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUUID = `-- name: FetchUserTeamByUUID :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     uuid = ?
`

func (q *Queries) FetchUserTeamByUUID(ctx context.Context, uuid string) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUUID, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUUIDForUpdate = `-- name: FetchUserTeamByUUIDForUpdate :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     uuid = ?      
FOR UPDATE
`

func (q *Queries) FetchUserTeamByUUIDForUpdate(ctx context.Context, uuid string) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUUIDForUpdate, uuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmail = `-- name: FetchUserTeamByUserEmail :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ?  
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmail(ctx context.Context, arg FetchUserTeamByUserEmailParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmail, arg.UserEmail, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndRole = `-- name: FetchUserTeamByUserEmailAndRole :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND role = ?  
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndRoleParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndRole(ctx context.Context, arg FetchUserTeamByUserEmailAndRoleParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndRole,
		arg.UserEmail,
		arg.Role,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndRoleAndStatus = `-- name: FetchUserTeamByUserEmailAndRoleAndStatus :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND role = ? AND status = ?  
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndRoleAndStatusParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndRoleAndStatus(ctx context.Context, arg FetchUserTeamByUserEmailAndRoleAndStatusParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndRoleAndStatus,
		arg.UserEmail,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndRoleAndStatusOrderedByCreatedAtASC = `-- name: FetchUserTeamByUserEmailAndRoleAndStatusOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND role = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndRoleAndStatusOrderedByCreatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndRoleAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserTeamByUserEmailAndRoleAndStatusOrderedByCreatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndRoleAndStatusOrderedByCreatedAtASC,
		arg.UserEmail,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndRoleAndStatusOrderedByCreatedAtDESC = `-- name: FetchUserTeamByUserEmailAndRoleAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND role = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndRoleAndStatusOrderedByCreatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndRoleAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserTeamByUserEmailAndRoleAndStatusOrderedByCreatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndRoleAndStatusOrderedByCreatedAtDESC,
		arg.UserEmail,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndRoleAndStatusOrderedByUpdatedAtASC = `-- name: FetchUserTeamByUserEmailAndRoleAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND role = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndRoleAndStatusOrderedByUpdatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndRoleAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserTeamByUserEmailAndRoleAndStatusOrderedByUpdatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndRoleAndStatusOrderedByUpdatedAtASC,
		arg.UserEmail,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndRoleAndStatusOrderedByUpdatedAtDESC = `-- name: FetchUserTeamByUserEmailAndRoleAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND role = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndRoleAndStatusOrderedByUpdatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndRoleAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserTeamByUserEmailAndRoleAndStatusOrderedByUpdatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndRoleAndStatusOrderedByUpdatedAtDESC,
		arg.UserEmail,
		arg.Role,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndRoleOrderedByCreatedAtASC = `-- name: FetchUserTeamByUserEmailAndRoleOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND role = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndRoleOrderedByCreatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndRoleOrderedByCreatedAtASC(ctx context.Context, arg FetchUserTeamByUserEmailAndRoleOrderedByCreatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndRoleOrderedByCreatedAtASC,
		arg.UserEmail,
		arg.Role,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndRoleOrderedByCreatedAtDESC = `-- name: FetchUserTeamByUserEmailAndRoleOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND role = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndRoleOrderedByCreatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndRoleOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserTeamByUserEmailAndRoleOrderedByCreatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndRoleOrderedByCreatedAtDESC,
		arg.UserEmail,
		arg.Role,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndRoleOrderedByUpdatedAtASC = `-- name: FetchUserTeamByUserEmailAndRoleOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND role = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndRoleOrderedByUpdatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndRoleOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserTeamByUserEmailAndRoleOrderedByUpdatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndRoleOrderedByUpdatedAtASC,
		arg.UserEmail,
		arg.Role,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndRoleOrderedByUpdatedAtDESC = `-- name: FetchUserTeamByUserEmailAndRoleOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND role = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndRoleOrderedByUpdatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Role      int64          `json:"role"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndRoleOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserTeamByUserEmailAndRoleOrderedByUpdatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndRoleOrderedByUpdatedAtDESC,
		arg.UserEmail,
		arg.Role,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndStatus = `-- name: FetchUserTeamByUserEmailAndStatus :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND status = ?  
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndStatusParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndStatus(ctx context.Context, arg FetchUserTeamByUserEmailAndStatusParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndStatus,
		arg.UserEmail,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndStatusOrderedByCreatedAtASC = `-- name: FetchUserTeamByUserEmailAndStatusOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND status = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndStatusOrderedByCreatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndStatusOrderedByCreatedAtASC(ctx context.Context, arg FetchUserTeamByUserEmailAndStatusOrderedByCreatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndStatusOrderedByCreatedAtASC,
		arg.UserEmail,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndStatusOrderedByCreatedAtDESC = `-- name: FetchUserTeamByUserEmailAndStatusOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND status = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndStatusOrderedByCreatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndStatusOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserTeamByUserEmailAndStatusOrderedByCreatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndStatusOrderedByCreatedAtDESC,
		arg.UserEmail,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndStatusOrderedByUpdatedAtASC = `-- name: FetchUserTeamByUserEmailAndStatusOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND status = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndStatusOrderedByUpdatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndStatusOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserTeamByUserEmailAndStatusOrderedByUpdatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndStatusOrderedByUpdatedAtASC,
		arg.UserEmail,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailAndStatusOrderedByUpdatedAtDESC = `-- name: FetchUserTeamByUserEmailAndStatusOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ? AND status = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailAndStatusOrderedByUpdatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Status    int64          `json:"status"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailAndStatusOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserTeamByUserEmailAndStatusOrderedByUpdatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailAndStatusOrderedByUpdatedAtDESC,
		arg.UserEmail,
		arg.Status,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailOrderedByCreatedAtASC = `-- name: FetchUserTeamByUserEmailOrderedByCreatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ?  
    ORDER BY created_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailOrderedByCreatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailOrderedByCreatedAtASC(ctx context.Context, arg FetchUserTeamByUserEmailOrderedByCreatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailOrderedByCreatedAtASC, arg.UserEmail, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailOrderedByCreatedAtDESC = `-- name: FetchUserTeamByUserEmailOrderedByCreatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ?  
    ORDER BY created_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailOrderedByCreatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailOrderedByCreatedAtDESC(ctx context.Context, arg FetchUserTeamByUserEmailOrderedByCreatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailOrderedByCreatedAtDESC, arg.UserEmail, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailOrderedByUpdatedAtASC = `-- name: FetchUserTeamByUserEmailOrderedByUpdatedAtASC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ?  
    ORDER BY updated_at ASC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailOrderedByUpdatedAtASCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailOrderedByUpdatedAtASC(ctx context.Context, arg FetchUserTeamByUserEmailOrderedByUpdatedAtASCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailOrderedByUpdatedAtASC, arg.UserEmail, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchUserTeamByUserEmailOrderedByUpdatedAtDESC = `-- name: FetchUserTeamByUserEmailOrderedByUpdatedAtDESC :many
SELECT uuid, user_uuid, user_email, team_uuid, role, review_required_structure, review_required_data, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM user_team
WHERE 
     user_email = ?  
    ORDER BY updated_at DESC
    LIMIT ?, ?
`

type FetchUserTeamByUserEmailOrderedByUpdatedAtDESCParams struct {
	UserEmail sql.NullString `json:"user_email"`
	Offset    int32          `json:"offset"`
	Limit     int32          `json:"limit"`
}

func (q *Queries) FetchUserTeamByUserEmailOrderedByUpdatedAtDESC(ctx context.Context, arg FetchUserTeamByUserEmailOrderedByUpdatedAtDESCParams) ([]UserTeam, error) {
	rows, err := q.db.QueryContext(ctx, fetchUserTeamByUserEmailOrderedByUpdatedAtDESC, arg.UserEmail, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserTeam
	for rows.Next() {
		var i UserTeam
		if err := rows.Scan(
			&i.UUID,
			&i.UserUUID,
			&i.UserEmail,
			&i.TeamUUID,
			&i.Role,
			&i.ReviewRequiredStructure,
			&i.ReviewRequiredData,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchChangeRequest = `-- name: SearchChangeRequest :many
SELECT uuid, version, title, description, project_uuid, project_version_uuid, change_type, data_changes, metadata, reviews, review_status, owner_uuid, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM change_request
WHERE 
    title like ? OR
    
    description like ? 
    LIMIT ?, ?
`

type SearchChangeRequestParams struct {
	Title       string         `json:"title"`
	Description sql.NullString `json:"description"`
	Offset      int32          `json:"offset"`
	Limit       int32          `json:"limit"`
}

func (q *Queries) SearchChangeRequest(ctx context.Context, arg SearchChangeRequestParams) ([]ChangeRequest, error) {
	rows, err := q.db.QueryContext(ctx, searchChangeRequest,
		arg.Title,
		arg.Description,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ChangeRequest
	for rows.Next() {
		var i ChangeRequest
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Title,
			&i.Description,
			&i.ProjectUUID,
			&i.ProjectVersionUUID,
			&i.ChangeType,
			&i.DataChanges,
			&i.Metadata,
			&i.Reviews,
			&i.ReviewStatus,
			&i.OwnerUUID,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchExtension = `-- name: SearchExtension :many
SELECT uuid, version, identifier, display_name, display_author_name, description, url, verfied, repository, extension_type, tags, public, visibility, status, owner_uuid, created_at, updated_at, created_by_uuid, updated_by_uuid FROM extension
WHERE 
    identifier like ? OR
    
    description like ? 
    LIMIT ?, ?
`

type SearchExtensionParams struct {
	Identifier  string         `json:"identifier"`
	Description sql.NullString `json:"description"`
	Offset      int32          `json:"offset"`
	Limit       int32          `json:"limit"`
}

func (q *Queries) SearchExtension(ctx context.Context, arg SearchExtensionParams) ([]Extension, error) {
	rows, err := q.db.QueryContext(ctx, searchExtension,
		arg.Identifier,
		arg.Description,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Extension
	for rows.Next() {
		var i Extension
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.DisplayName,
			&i.DisplayAuthorName,
			&i.Description,
			&i.URL,
			&i.Verfied,
			&i.Repository,
			&i.ExtensionType,
			&i.Tags,
			&i.Public,
			&i.Visibility,
			&i.Status,
			&i.OwnerUUID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchOrganization = `-- name: SearchOrganization :many
SELECT uuid, version, name, domains, admin_uuids, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM organization
WHERE 
    name like ? 
    LIMIT ?, ?
`

type SearchOrganizationParams struct {
	Name   string `json:"name"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) SearchOrganization(ctx context.Context, arg SearchOrganizationParams) ([]Organization, error) {
	rows, err := q.db.QueryContext(ctx, searchOrganization, arg.Name, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Organization
	for rows.Next() {
		var i Organization
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Domains,
			&i.AdminUUIDs,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProject = `-- name: SearchProject :many
SELECT uuid, version, name, description, tags, url, owner_uuid, team_uuid, access_type, project_extensions, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project
WHERE 
    name like ? OR
    
    description like ? 
    LIMIT ?, ?
`

type SearchProjectParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
	Offset      int32          `json:"offset"`
	Limit       int32          `json:"limit"`
}

func (q *Queries) SearchProject(ctx context.Context, arg SearchProjectParams) ([]Project, error) {
	rows, err := q.db.QueryContext(ctx, searchProject,
		arg.Name,
		arg.Description,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Description,
			&i.Tags,
			&i.URL,
			&i.OwnerUUID,
			&i.TeamUUID,
			&i.AccessType,
			&i.ProjectExtensions,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProjectVersion = `-- name: SearchProjectVersion :many
SELECT uuid, version, identifier, description, project_uuid, entities, relationships, enums, services, base_version_uuid, review_status, deployments, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM project_version
WHERE 
    description like ? 
    LIMIT ?, ?
`

type SearchProjectVersionParams struct {
	Description string `json:"description"`
	Offset      int32  `json:"offset"`
	Limit       int32  `json:"limit"`
}

func (q *Queries) SearchProjectVersion(ctx context.Context, arg SearchProjectVersionParams) ([]ProjectVersion, error) {
	rows, err := q.db.QueryContext(ctx, searchProjectVersion, arg.Description, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ProjectVersion
	for rows.Next() {
		var i ProjectVersion
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Identifier,
			&i.Description,
			&i.ProjectUUID,
			&i.Entities,
			&i.Relationships,
			&i.Enums,
			&i.Services,
			&i.BaseVersionUUID,
			&i.ReviewStatus,
			&i.Deployments,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchTeam = `-- name: SearchTeam :many
SELECT uuid, version, name, enviorments, review_configs, stores, connections, object_stores, organization_uuid, default_entity, status, created_at, updated_at, created_by_uuid, updated_by_uuid FROM team
WHERE 
    name like ? 
    LIMIT ?, ?
`

type SearchTeamParams struct {
	Name   string `json:"name"`
	Offset int32  `json:"offset"`
	Limit  int32  `json:"limit"`
}

func (q *Queries) SearchTeam(ctx context.Context, arg SearchTeamParams) ([]Team, error) {
	rows, err := q.db.QueryContext(ctx, searchTeam, arg.Name, arg.Offset, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Team
	for rows.Next() {
		var i Team
		if err := rows.Scan(
			&i.UUID,
			&i.Version,
			&i.Name,
			&i.Enviorments,
			&i.ReviewConfigs,
			&i.Stores,
			&i.Connections,
			&i.ObjectStores,
			&i.OrganizationUUID,
			&i.DefaultEntity,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CreatedByUUID,
			&i.UpdatedByUUID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
